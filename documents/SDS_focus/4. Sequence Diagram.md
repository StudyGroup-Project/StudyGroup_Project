

# **4\. Sequence diagram**
---


## 이현철 작성 목록

| 번호 | 기능 | 번호 | 기능 | 번호 | 기능 | 번호 | 기능 | 번호 | 기능 |
|------|------|------|------|------|------|------|------|------|------|
| 1 | 시스템 로그인하기 | 2 | OAuth 로그인하기 | 3 | 로그아웃하기 | 4 | 회원가입하기 | 5 | 아이디 중복 확인하기 |
| 6 | 초기 프로필정보 설정하기(이미지 제외) | 7 | 내 프로필 정보 수정하기 | 8 | 내 프로필 이미지 설정하기 | 9 | 내 프로필 불러오기 | 10 | 메인화면 데이터 가져오기 |
| 11 | 스터디 그룹 검색하기 | 49 | 채팅목록 가져오기 | 50 | 채팅하기 |  |  |  |



## 이시형 작성 목록

| 번호 | 기능 | 번호 | 기능 | 번호 | 기능 | 번호 | 기능 | 번호 | 기능 |
|------|------|------|------|------|------|------|------|------|------|
| 12 | 그룹원 목록 조회 | 13 | 공지 목록 조회 | 14 | 공지 생성 | 15 | 공지 수정 | 16 | 공지 삭제 |
| 17 | 공지 상세 조회 | 18 | 공지 댓글 달기 | 19 | 자료 목록 조회 | 20 | 자료 생성 | 21 | 자료 수정 |
| 22 | 자료 삭제 | 23 | 자료 상세 데이터 가져오기 |  |  |  |  |  |


## 강보성 작성 목록

| 번호 | 기능 | 번호 | 기능 | 번호 | 기능 | 번호 | 기능 | 번호 | 기능 |
|------|------|------|------|------|------|------|------|------|------|
| 24 | 스터디 그룹 찜하기 | 25 | 스터디 그룹 찜 해제하기 | 26 | 스터디 그룹 지원서 제출하기 | 27 | 스터디 그룹 생성하기 | 28 | 그룹 프로필 정보 조회하기 |
| 29 | 그룹 프로필 정보 수정하기 | 30 | 그룹 삭제하기 | 31 | 그룹 탈퇴하기 | 32 | 그룹원 강퇴하기 | 33 | 그룹 지원서 목록 조회하기 |
| 34 | 그룹 지원서 상세 조회하기 | 35 | 그룹 지원 승인하기 | 36 | 그룹 지원 거절하기 |  |  |  |  |  |



---

4.1. 시스템 로그인하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/84438528b7cbfd561e410248c13187d7747129ad/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%201.png)
그림 \# sequence 1

이 시퀀스 다이어그램은 사용자가 자체 계정 정보를 이용하여 로그인할 때, Spring MVC 백엔드 내부에서 처리되는 인증 과정을 단계적으로 나타낸 것이다.  
 로그인 요청은 컨트롤러 계층에서 시작된다. 사용자가 입력한 이메일과 비밀번호는 AccountController로 전달되고, 컨트롤러는 이 정보를 기반으로 AccountService의 login 메서드를 호출한다.

AccountService는 내부적으로 시스템 자격 증명 검증을 담당하는 SystemCredentialPassword 객체를 이용하여 비밀번호의 유효성을 확인한다. 이때 사용자가 입력한 평문 비밀번호는 데이터베이스에 저장된 암호화된 비밀번호와 비교되며, 일치할 경우 인증이 성공으로 처리된다. 인증에 성공하면 AccountService는 사용자 정보를 기반으로 JWT 발급 절차를 수행하기 위해 TokenService를 호출한다.

TokenService는 JwtTokenProvider를 통해 Access Token을 생성하고, 동시에 RefreshTokenService를 통해 Refresh Token을 발급한다. 발급된 두 토큰은 TokenResponse 형태로 묶여 AccountService로 반환되며, AccountService는 이를 LoginResponse 객체로 변환하여 AccountController로 전달한다.

AccountController는 반환된 토큰 정보를 응답 본문에 포함하여 클라이언트로 전달하고, Refresh Token은 추가적인 보안 강화를 위해 쿠키 형태로 저장된다. 이때 사용자는 이후의 모든 요청에서 Access Token을 인증 헤더에 포함시켜 인증된 상태로 서비스를 이용할 수 있게 된다.

이 시퀀스 다이어그램은 사용자의 로그인 요청부터 비밀번호 검증, 토큰 발급, 쿠키 저장, 그리고 응답 반환에 이르는 전 과정을 표현한다.

4.2. OAuth 로그인하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/ca0d819133db773e5b6c101a535cfdac06b4f050/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%202.png)

그림 \#  sequence 2

이 시퀀스 다이어그램은 사용자가 외부 인증 제공자(Google, Kakao, Naver 등)의 계정을 이용하여 로그인할 때, Spring MVC 백엔드 내부에서 동작하는 인증 처리 절차를 단계적으로 나타낸 것이다.  
 사용자가 클라이언트 화면에서 OAuth 로그인 버튼을 클릭하면 브라우저는 외부 인증 제공자의 로그인 페이지로 리다이렉트된다. 사용자가 해당 서비스에서 인증을 완료하고 동의를 허용하면, 인증 서버는 시스템의 콜백 URL로 인가 코드를 전달하며, 이 시점부터 백엔드 내부의 시퀀스가 실행된다.

먼저 Spring Security는 인가 코드를 전달받아 OAuth2UserCustomService의 loadUser 메서드를 호출한다. 이 서비스는 외부 Provider로부터 사용자 정보를 요청하고, 응답으로 전달된 식별자(providerUserId)와 프로필 데이터를 바탕으로 데이터베이스 내의 User와 OAuthCredential 정보를 조회하거나, 존재하지 않을 경우 새로 생성한다. 이후 마지막 로그인 시각(lastLoginAt)을 갱신하고, 인증 정보를 담은 CustomOAuth2User(userId, attributes) 객체를 반환한다. 이 객체는 Spring Security의 SecurityContext에 저장되어 이후 요청 시 인증 주체로 사용된다. 이 단계에서는 외부 인증 결과를 내부 사용자 엔티티와 연결하는 역할만 수행하며, JWT 발급이나 Refresh Token 저장은 이루어지지 않는다.

다음 단계로 인증이 성공하면 OAuth2SuccessHandler가 실행된다. 이 핸들러는 SecurityContext에 저장된 CustomOAuth2User로부터 provider와 providerUserId를 확인하고, AccountService의 oauthLogin 메서드를 호출한다. AccountService는 데이터베이스에서 해당 사용자와 연결된 User 및 OAuthCredential을 조회하여 보장한 뒤, TokenService를 통해 Access Token(JWT)을 발급하고, RefreshTokenService를 통해 Refresh Token을 생성 및 저장한다. 두 토큰은 LoginResponse(accessToken, refreshToken) 형태로 반환되어 핸들러로 전달된다.

OAuth2SuccessHandler는 반환된 응답을 바탕으로 Refresh Token을 보안 쿠키에 저장하고, Access Token을 포함한 리다이렉트 URL을 생성한다. 사용자의 브라우저는 이 URL로 이동하며, 프론트엔드는 전달받은 Access Token을 저장하여 이후의 API 요청 시 인증 헤더에 포함시켜 보낸다. 이후 요청은 모두 TokenAuthenticationFilter를 거치며, 이 필터는 JWT의 유효성을 검증하고, 정상적인 경우 SecurityContext에 사용자 식별자(userId)를 저장해 인증 상태를 유지한다.

이 시퀀스 다이어그램은 외부 OAuth 인증 과정 이후, 백엔드 내부에서 사용자 정보 확인, 토큰 발급, 쿠키 저장, 리다이렉트 처리에 이르는 전체 흐름을 구체적으로 보여준다. 즉, 클라이언트에서는 단순히 버튼 클릭과 리다이렉트가 발생하지만, 실제 핵심 로직은 Spring MVC 백엔드 내부의 OAuth2UserCustomService, OAuth2SuccessHandler, AccountService, TokenService, RefreshTokenService 간의 상호작용을 통해 수행된다.

4.3. 로그아웃하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/ca0d819133db773e5b6c101a535cfdac06b4f050/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%203.png)

그림 \#  sequence 3

이 시퀀스 다이어그램은 사용자가 로그아웃 요청을 수행했을 때, Spring MVC 백엔드 내부에서 Refresh Token을 이용해 세션 정보를 무효화하는 과정을 단계적으로 나타낸 것이다.  
 사용자가 로그아웃 요청을 전송하면, 해당 요청은 AuthController로 전달된다. 컨트롤러는 요청에 포함된 Refresh Token의 존재 여부를 먼저 확인한다. 조건문 블록(alt)은 Refresh Token이 존재하는 경우에만 로그아웃 절차를 수행함을 의미한다.

Refresh Token이 존재할 경우, 컨트롤러는 AccountService의 logoutByRefreshToken 메서드를 호출한다. 이 서비스 메서드는 전달받은 Refresh Token을 기준으로 데이터베이스에 저장된 토큰 정보를 조회하기 위해 RefreshTokenRepository의 findByToken 메서드를 호출한다.  
 조회된 토큰이 존재할 경우, 해당 토큰은 삭제되거나 만료 상태로 갱신되어 더 이상 인증에 사용할 수 없게 된다. 이를 통해 사용자의 인증 세션이 완전히 종료되며, 이후 동일한 Refresh Token으로 새로운 Access Token을 발급받을 수 없게 된다.

4.4. 회원가입하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/ca0d819133db773e5b6c101a535cfdac06b4f050/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%204.png)

그림 \#  sequence 4

이 시퀀스 다이어그램은 사용자가 회원가입 요청을 수행했을 때, Spring MVC 백엔드 내부에서 새로운 계정을 생성하는 과정을 단계적으로 나타낸 것이다.  
 회원가입 요청은 AuthController에서 시작된다. 사용자가 입력한 로그인 아이디와 비밀번호, 기타 필수 정보를 담은 요청 객체가 컨트롤러에 전달되면, 컨트롤러는 이를 AccountService의 register 메서드에 위임한다.

AccountService는 우선 중복 가입 여부를 확인하기 위해 SystemCredentialRepository의 existsByLoginId 메서드를 호출한다. 이 메서드는 전달받은 로그인 아이디가 이미 존재하는지를 조회하며, 만약 동일한 아이디가 존재할 경우 BusinessException을 발생시켜 회원가입 절차를 중단한다.  
 반대로 동일한 아이디가 존재하지 않는 경우, AccountService는 새로운 사용자 엔티티 생성을 위한 빌더 로직을 실행한다.

UserBuilder는 사용자의 기본 정보를 기반으로 User 객체를 생성하고, 동시에 SystemCredentialBuilder가 호출되어 로그인 자격 증명 정보를 구성한다. 이때 사용자 입력값으로부터 loginId와 password가 설정되며, password는 암호화 과정을 거쳐 저장될 준비를 마친다. 이후 두 빌더가 완성되면 User와 SystemCredential 엔티티가 연관된 형태로 생성되어 AccountService로 반환된다.

AccountService는 완성된 User 객체를 데이터베이스에 저장하고, 최종적으로 회원가입이 성공적으로 완료되었음을 AuthController로 반환한다. 컨트롤러는 이 결과를 클라이언트에 전달하여 회원가입 절차를 마무리한다.

4.5. 아이디 중복 확인하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/ca0d819133db773e5b6c101a535cfdac06b4f050/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%205.png)

그림 \#  sequence 5

이 시퀀스 다이어그램은 사용자가 회원가입 과정에서 입력한 로그인 아이디가 이미 존재하는지를 확인하기 위해, Spring MVC 백엔드 내부에서 수행되는 절차를 단계적으로 나타낸 것이다.  
 요청은 AuthController에서 시작된다. 사용자가 입력한 아이디를 전달받은 컨트롤러는 AccountService의 checkId 메서드를 호출하여 중복 여부를 확인한다.

AccountService는 SystemCredentialRepository의 existsByLoginId 메서드를 호출하여 데이터베이스에 동일한 로그인 아이디가 존재하는지 조회한다. 해당 메서드는 불리언 값을 반환하며, 아이디가 이미 존재하면 true, 존재하지 않으면 false로 결과가 전달된다. AccountService는 이 결과를 바탕으로 CheckDuplicatedIdResponse 객체를 생성하고, 중복 여부를 명시한 응답 데이터를 AuthController로 반환한다.

컨트롤러는 AccountService로부터 전달받은 응답을 최종적으로 클라이언트에 전달하여, 사용자가 입력한 아이디의 사용 가능 여부를 실시간으로 확인할 수 있도록 한다.

4.6. 초기 프로필 정보 설정하기(이미지 제외)

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/ca0d819133db773e5b6c101a535cfdac06b4f050/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%206.png)

그림 \#  sequence 6

이 시퀀스 다이어그램은 사용자가 회원가입 이후 처음으로 프로필 정보를 설정할 때, Spring MVC 백엔드 내부에서 수행되는 절차를 단계적으로 나타낸 것이다.  
 요청은 UserController에서 시작된다. 사용자가 입력한 프로필 정보(닉네임, 생년월일, 직업, 선호 카테고리 등)는 컨트롤러를 통해 UserService의 initProfile 메서드로 전달된다.

UserService는 먼저 findUser 메서드를 호출하여 요청을 보낸 사용자가 실제로 존재하는지 확인한다. 만약 데이터베이스에 해당 사용자가 존재하지 않을 경우 BusinessException을 발생시켜 처리를 중단한다. 반대로 사용자가 존재할 경우, 새로운 프로필 생성을 위해 UserProfile 엔티티를 초기화한다. 이때 주소 정보가 필요한 경우 Address 객체가 함께 생성된다.

다음 단계에서는 UserProfileBuilder가 호출되어 개별 속성들이 순차적으로 설정된다. 빌더는 user, nickname, address, birthDate, job, preferredCategory 등의 필드를 채워나가며, 입력된 모든 정보가 정상적으로 반영되면 build 메서드를 통해 완성된 UserProfile 객체를 생성한다. 완성된 프로필 객체는 UserService로 반환되고, UserService는 이를 데이터베이스에 저장하여 사용자 계정과 연결한다.

모든 처리가 완료되면 UserController는 초기 프로필 설정 결과를 클라이언트에 반환한다. 이 과정을 통해 사용자는 최초 로그인 이후 자신의 기본 정보를 등록하게 되며, 이후 서비스 내에서 개인화된 환경을 이용할 수 있게 된다.

4.7. 내 프로필 정보 수정하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/ca0d819133db773e5b6c101a535cfdac06b4f050/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%207.png)

그림 \#  sequence 7

이 시퀀스 다이어그램은 사용자가 기존에 등록한 프로필 정보를 수정할 때, Spring MVC 백엔드 내부에서 수행되는 절차를 단계적으로 나타낸 것이다.  
 요청은 UserController에서 시작된다. 사용자가 수정할 프로필 정보를 입력하고 요청을 전송하면, 컨트롤러는 해당 데이터를 UserService의 updateProfile 메서드로 전달한다.

UserService는 우선 사용자의 기존 프로필 정보를 조회하기 위해 findUserProfile 메서드를 호출한다. 이 메서드는 UserProfileRepository의 findByUserId 메서드를 이용해 데이터베이스에서 해당 사용자의 프로필 엔티티를 탐색한다. 만약 프로필 정보가 존재하지 않을 경우 BusinessException을 발생시키거나, 새로운 프로필 객체를 생성하여 초기화한다.

프로필 엔티티가 확인되면, 수정된 정보가 반영될 Address 객체가 새로 생성되거나 기존 데이터가 갱신된다. 이후 UserProfile 엔티티의 updateProfile 메서드를 호출하여 전달받은 닉네임, 주소, 생년월일, 직업, 선호 카테고리 등의 변경사항을 적용한다. 수정이 완료된 UserProfile 객체는 데이터베이스에 저장되며, 이를 통해 사용자의 최신 프로필 정보가 반영된다.

모든 수정이 완료되면 UserController는 수정 결과를 클라이언트에 반환하여, 사용자는 갱신된 프로필 정보를 확인할 수 있다.

4.8. 내 프로필 이미지 설정하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/ca0d819133db773e5b6c101a535cfdac06b4f050/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%208.png)

그림 \#  sequence 8

이 시퀀스 다이어그램은 사용자가 자신의 프로필 이미지를 설정하거나 변경할 때, Spring MVC 백엔드 내부에서 수행되는 절차를 단계적으로 나타낸 것이다.  
 요청은 UserController에서 시작된다. 사용자가 업로드한 이미지 파일이 컨트롤러로 전달되면, 컨트롤러는 이 파일과 함께 사용자 식별 정보를 UserService의 updateProfileImage 메서드에 전달한다.

UserService는 먼저 사용자의 프로필 정보를 조회하기 위해 UserProfileRepository를 호출한다. findByUserId 메서드를 통해 데이터베이스에서 해당 사용자의 프로필을 탐색하며, 존재하지 않을 경우 BusinessException을 발생시켜 예외를 처리한다. 프로필이 존재할 경우, 서비스는 이미지 저장을 위해 FileService 또는 StorageService 계층을 호출한다.

이미지 파일은 저장 경로를 생성하는 과정을 거쳐 서버 내부 또는 외부 스토리지(S3 등)에 업로드된다. 이 과정에서 기존 프로필 이미지가 존재하는 경우에는 삭제 요청이 먼저 수행되어, 중복 저장이나 불필요한 파일 누적을 방지한다. 새로운 이미지 업로드가 성공하면, File 엔티티가 생성되어 파일의 경로(URL), 크기, 타입 등의 메타데이터가 저장된다.

이후 UserService는 UserProfile 엔티티의 updateProfileImage 메서드를 호출하여 새로 저장된 이미지 파일의 경로를 프로필 정보에 반영한다. 변경된 UserProfile은 데이터베이스에 갱신되어, 사용자의 최신 프로필 이미지가 적용된다.

모든 절차가 완료되면 UserController는 성공 응답을 클라이언트로 반환한다. 사용자는 갱신된 프로필 이미지를 즉시 확인할 수 있으며, 이후 서비스 내의 다른 기능에서도 새로운 이미지가 반영되어 표시된다.

4.9. 내 프로필 불러오기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/ca0d819133db773e5b6c101a535cfdac06b4f050/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%209.png)

그림 \#  sequence 9

이 시퀀스 다이어그램은 사용자가 자신의 프로필 정보를 조회할 때, Spring MVC 백엔드 내부에서 수행되는 절차를 단계적으로 나타낸 것이다.  
 요청은 UserController에서 시작된다. 사용자가 프로필 조회 요청을 전송하면, 컨트롤러는 사용자 식별 정보를 포함하여 UserService의 getMyProfile 메서드를 호출한다.

UserService는 먼저 findUserProfile 메서드를 호출하여 데이터베이스에서 해당 사용자의 프로필 정보를 조회한다. 이때 UserProfileRepository의 findByUserId 메서드가 실행되어 사용자의 프로필 엔티티를 탐색한다. 만약 프로필 정보가 존재하지 않을 경우 BusinessException이 발생하거나, 예외 상황을 처리하기 위한 기본 프로필 객체가 생성된다.

조회된 프로필 정보가 정상적으로 존재하면 UserService는 이를 기반으로 GetMyProfileResponse 객체를 생성한다. 이 응답 객체에는 사용자의 닉네임, 주소, 생년월일, 직업, 선호 카테고리 등 프로필 주요 정보가 포함된다. 생성된 응답은 UserController로 반환되며, 컨트롤러는 이를 클라이언트에 전달하여 사용자가 자신의 프로필 정보를 확인할 수 있도록 한다.

4.10. 메인화면 데이터 가져오기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/ca0d819133db773e5b6c101a535cfdac06b4f050/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%2010.png)

그림 \#  sequence 10

이 시퀀스 다이어그램은 사용자가 메인화면에 접속했을 때, Spring MVC 백엔드 내부에서 사용자 정보와 스터디 관련 데이터를 종합하여 홈 화면 구성을 위한 데이터를 반환하는 과정을 단계적으로 나타낸 것이다.  
 요청은 HomeController에서 시작된다. 사용자가 메인화면에 접근하면 컨트롤러는 HomeService의 getHomeData 메서드를 호출하여 필요한 데이터를 조회한다.

HomeService는 우선 로그인한 사용자의 프로필 정보를 가져오기 위해 UserProfileRepository의 findByUserId 메서드를 호출한다. 데이터베이스에 해당 프로필이 존재하지 않을 경우 BusinessException을 발생시키거나 기본 프로필 객체를 생성하여 예외를 처리한다. 이후 조회된 프로필의 이미지가 존재하는지 확인한 뒤, 이미지 파일이 있을 경우 S3Uploader의 getUrlFile 메서드를 통해 이미지의 실제 접근 경로(URL)를 불러온다. 이미지 키가 유효한지 검증하는 과정도 함께 수행된다.

프로필 정보 처리가 완료되면 HomeService는 사용자가 참여한 스터디 정보를 불러오기 위해 StudyMemberRepository를 호출한다. 이 단계에서 findTop10StudyProfiles 메서드를 이용하여 사용자가 속한 주요 스터디 리스트를 조회한다.  
 이후 사용자가 리더로 등록된 스터디 수, 참여 중인 스터디 수, 완료된 스터디 수 등을 각각 countByStudyIdAndStatus 또는 countByStudyId 메서드를 통해 계산한다. 또한 StudyMemberRepository의 findLeaderTrustScoreByStudyId 메서드를 호출하여 사용자가 리더로서 받은 신뢰 점수나 평가 데이터를 함께 조회한다.

이렇게 수집된 정보는 StudyDto와 UserDto 객체로 가공되어, HomeService 내부에서 HomeResponse 객체로 통합된다. HomeResponse에는 사용자 프로필, 프로필 이미지 URL, 참여 스터디 통계, 추천 스터디 목록 등 메인화면을 구성하는 데 필요한 핵심 데이터가 포함된다.

모든 데이터가 준비되면 HomeController는 HomeResponse를 반환하여 클라이언트에 전달한다. 클라이언트는 해당 응답을 바탕으로 사용자 맞춤형 메인화면을 렌더링하게 된다.

4.11. 스터디 그룹 검색하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/ca0d819133db773e5b6c101a535cfdac06b4f050/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%2011.png)

그림 \#  sequence 11

이 시퀀스 다이어그램은 사용자가 검색 조건을 입력하여 스터디 그룹을 조회할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
 요청은 StudyQueryController에서 시작된다. 사용자가 검색어, 카테고리, 정렬 조건 등의 파라미터를 포함해 요청을 전송하면, 컨트롤러는 이를 StudyQueryService의 searchStudies 메서드로 전달한다.

StudyQueryService는 우선 정렬 조건을 설정하기 위해 getSort 메서드를 호출한다. 이후 검색 로직을 수행하기 위해 StudyRepositoryCustom의 searchStudies 메서드를 호출한다. 이 단계에서 QueryDSL 기반의 동적 쿼리가 실행되며, 검색 조건에 맞는 스터디 목록을 데이터베이스에서 조회한다.  
 StudyRepositoryImpl 내부에서는 검색 조건에 따라 여러 Q 객체(QStudy, QUser, QStudyMember 등)가 조합되어 쿼리가 구성된다. 각 조건에 맞는 필터링 절차가 수행되며, 결과 정렬을 위한 toOrderSpecifier 메서드가 호출된다.

조회된 결과는 페이징 처리를 위해 page, limit, totalCount, totalPages 등의 정보를 계산하여 Meta 객체로 정리된다. 이후 SearchStudiesResponseBuilder가 호출되어 조회된 스터디 목록(studies)과 메타데이터(meta)가 결합된다. 모든 데이터가 빌드되면 최종적으로 SearchStudiesResponse 객체가 생성되어 StudyQueryService로 반환된다.

StudyQueryService는 완성된 응답 객체를 StudyQueryController로 전달하고, 컨트롤러는 이를 클라이언트에 반환한다. 클라이언트는 응답 데이터를 기반으로 스터디 목록과 페이지 정보를 화면에 출력하게 된다.

4.12. 그룹원 목록 조회

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/bf03e119074a680f97525c848e257038dae63aeb/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2012.png)
그림 \# sequence 12.png

위 그림은 스터디 그룹원 목록 조회 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다.

1. **클라이언트 요청**  
- 사용자가 스터디 그룹원의 목록을 조회하면, 클라이언트는 서버로 요청을 전송한다.  
2. **Controller 계층 처리**  
- 서버는 컨트롤러의 getMembers() 메서드를 호출하여 요청을 처리한다.  
- 이 메서드는 스터디원 목록을 조회하기 위해 Service 계층의 getMembers() 메서드드를 호출하며, 요청자의 userId와 studyId를 인수로 전달한다.  
3. **Service 계층 검증 및 데이터 조회**  
- Service 내부에서는 먼저 GroupService의 memberValidation() 메서드드를 호출해 요청한 사용자가 해당 스터디의 구성원인지 먼저 검증한다.  
- 검증에 실패한 경우 예외가 발생하며, 클라이언트에는 HTTP 400 에러 코드가 반환된다.  
- 검증이 통과되면, StudyMemberRepository의 findAllByStudy\_IdAndStatus 메서드드를 호출해 요청한 스터디에 속한 모든 그룹원 정보를 조회한다.  
4. **사용자 메타데이터 조회**  
- 조회된 각 스터디원에 대해 UserService의 getMyProfile() 함수를 호출하여 사용자의 모든 정보를 조회한다.  
- 조회한 사용자의 정보에서 닉네임,userId, 프로필 이미지, 역할, 마지막 로그인 일자만을 추출하여 응답 DTO List를 생성하고 Controller 계층에 반환한다.  
5. **클라이언트에 응답 반환**  
- Controller는 서비스 계층으로부터 받은 스터디원 정보 리스트를 응답 본문에 담아 HTTP 200 OK 코드와 함께 클라이언트에 반환한다.

4.13. 공지 목록 조회

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2013.png)
그림 \# sequence 13.png

위 그림은 스터디 내 생성된 공지 목록 조회 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다.

1. **클라이언트 요청**   
- 사용자가 특정 스터디의 공지 목록을 조회하면, 클라이언트는 서버로 요청을 전송한다.  
2. **Controller 계층 처리**  
- 서버는 컨트롤러의 getAnnouncements() 메서드를 호출하여 요청을 처리한다.  
-  이 메서드는 공지 데이터를 조회하기 위해 AnnouncementService의 findAllSummaries() 메서드를 호출하며, studyId와 userId를 인수로 전달한다.”  
3. **Service 계층 검증 및 데이터 조회**  
- Service 내부에서는 먼저 GroupService의 memberValidation() 메서드를 호출하여 요청한 사용자가 해당 스터디의 그룹원인지 검증한다.  
- 만약 검증에 실패하면 예외가 발생하고, 클라이언트에는 HTTP 400 에러 코드가 반환된다.  
- 검증에 성공하면 AnnouncementRepository의 findAllByStudyId()  함수를 호출해  스터디에 속한 모든 공지 목록을 조회한다.  
4. **공지 데이터 가공 및 반환**   
- 조회된 공지 목록에서 공지 ID, 제목, 생성일자를 추출하여 DTO 리스트로 변환한다. 이후 이 DTO 리스트를 컨트롤러 계층으로 반환한다.  
5. **응답 반환**  
- Controller는 서비스 계층으로부터 전달받은 DTO 리스트를 HTTP 200 OK 코드와 함께 클라이언트에 응답 본문으로 반환한다. 

4.14. 공지 생성

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2014.png) 
그림 \# sequence 14.png

위 그림은 스터디 내 공지 생성 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다.

1. **클라이언트 요청**  
- 관리자가 새로운 공지를 등록하면, 클라이언트는 서버로 공지 생성 요청을 전송한다.  
2. **Controller 계층 처리**  
- 서버는 컨트롤러의 createAnnouncement() 메서드를 호출하여 요청을 처리한다. 이 메서드는 공지 생성을 위해 AnnouncementService 계층의 createAnnouncement() 메서드를 호출하며, studyId, userId, 공지 제목, 내용, 첨부 파일을 인수로 전달한다.  
3. **Service 계층 검증 단계**  
   1. **그룹원 검증**  
-   먼저 GroupService의 memberValidation() 함수를 호출해 요청한 사용자가 해당 스터디의 그룹원인지 검증한다. 만약 그룹원이 아닐 경우 예외가 발생하며, 400 에러 코드가 반환된다.  
  2. **방장 권한 검증**  
- 그룹원임이 확인되면, 공지 생성이 방장 권한 기능이므로 GroupService의 isLeader() 함수를 호출해 요청자가 스터디의 방장인지 검증한다. 만약 방장이 아닐 경우 예외가 발생하며, 403 에러 코드가 반환된다.  
4. **공지 생성 및 저장**   
- 모든 검증을 통과하면, 요청 받은 데이터로 새로운 공지 객체를 생성하고 announcementRepository.save() 함수를 통해 DB에 공지를 저장한다.  
5. **알림(Notification) 처리**   
- 공지 생성 후, NotificationService.addAnnouncementNotification() 함수를 호출하여 공지 등록 알림을 생성한다.  
6. **첨부 파일 처리**  
- 사용자가 요청 시 첨부 파일을 포함했다면, 각 파일에 대한 메타데이터를 생성하여 File 테이블에 저장하고, 실제 파일 데이터는 AWS S3 스토리지 스토리지에 업로드한다. 만약 AWS 업로드 중 알 수 없는 예외가 발생하면, 500 에러 코드가 반환된다.  
7. **응답 반환**  
- 모든 로직이 정상적으로 완료되면, 컨트롤러는 HTTP 201 Created 응답 코드를 클라이언트에게 반환한다. 

4.15.공지 수정

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2015.png)
그림 \# sequence 15.png

위 그림은 스터디 내 공지 수정 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다.

1. **클라이언트 요청**  
- 사용자가 공지를 수정하면, 클라이언트는 서버로 공지 수정 요청을 전송한다.  
2. **Controller 계층 처리**  
- 서버는 컨트롤러의 updateAnnouncement() 메서드를 호출하여 요청을 처리한다.  
- 컨트롤러는 공지 수정을 위해 AnnouncementService의 updateAnnouncement() 함수를 호출하며,  StudyId, announcementId, userId, 수정된 공지 내용을 인수로 전달한다.





3. **Service 계층 검증 단계**   
   1. **그룹원 검증**  
- GroupService의 memberValidation() 메서드를 호출해 요청자가 해당 스터디의 그룹원인지 검증한다.  
- 그룹원이 아닐 경우 예외가 발생하며, 400 에러 코드가 반환된다.  
  2. **방장 권한 검증**  
- 그룹원임이 확인되면, GroupService의 isLeader() 함수를 호출해 사용자가 스터디의 방장인지 검증한다.  
- 방장이 아닐 경우 예외가 발생하며, 403 에러 코드가 반환된다.  
4. **공지 존재 여부 검증**  
- 검증이 모두 통과되면, AnnouncementRepository.findByIdAndStudy\_IdAndAuthor\_Id() 함수를 호출하여 공지 ID, 스터디 ID, 작성자 ID가 일치하는 공지가 존재하는지 확인한다.  
- 해당 조건을 만족하는 공지가 없을 경우 예외가 발생하며, 400 에러 코드가 반환된다.  
5. **공지 내용 수정 및 파일 처리**   
   1. **공지 내용 수정**  
- 존재하는 공지가 확인되면, 전달받은 수정 내용을 기존 엔티티에 반영한다.  
  2. **기존 파일 삭제 처리**   
- 삭제 요청이 포함된 경우 ,FileRepository.findAllById()로 삭제 대상 파일을 조회한다.  
- 이후 해당 파일의 isDeleted 필드를 true로 변경하고, 공지와의 외래키 참조를 null로 설정하여 논리적 삭제(예약 삭제)를 수행한다.  
  3. **새 파일 추가 처리**  
- 수정 시 새로 첨부할 파일이 있다면, 파일의 메타데이터를 DB에 저장하고 실제 파일 원본은 AWS S3에 업로드한다.  
6. **응답 반환**  
- 모든 수정 작업이 정상적으로 완료되면, 컨트롤러는 HTTP 200 OK 코드를 클라이언트에 반환한다.

4.16. 공지 삭제

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2016.png)
그림 \# sequence 16.png

위 그림은 스터디 내 공지 삭제 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다.

1. **클라이언트 요청**  
- 사용자가 공지를 삭제하면, 클라이언트는 서버로 공지 삭제 요청을 전송한다.  
2.  **Controller 계층 처리**  
- 서버는 컨트롤러의deleteAnnouncement() 메서드를 호출하여 요청을 처리한다.  
- 컨트롤러는 공지 삭제를 위해 AnnouncementService의 deleteAnnouncement() 함수를 호출하며, studyId, userId, announcementId를 인수로 전달한다.  
3. **Service 계층 검증 단계**   
   1. **그룹원 검증**   
- GroupService의 memberValidation() 메서드를 호출해 요청자가 해당 스터디의 그룹원인지 확인한다.  
- 그룹원이 아닐 경우 예외가 발생하며, 400 에러 코드가 반환된다.  
  2. **방장 권한 검증**  
- 그룹원임이 확인되면, GroupSerivce의 isLeader() 함수를 호출해 요청자가 스터디의 방장인지 검증한다.  
- 방장이 아닐 경우 예외가 발생하며, 403 에러 코드가 반환된다.  
4. **공지 존재 여부 검증**  
- 검증이 모두 통과되면, AnnouncementRepository.findByIdAndStudy\_IdAndAuthor\_Id() 함수를 호출하여 공지 ID, 스터디 ID, 스터디원 ID가 일치하는 공지가 존재하는지 확인한다..  
- 해당 조건을 모두 만족하는 공지가 없을 경우 예외가 발생하며, 400 에러 코드가 반환된다.

5. **공지 삭제 처리 절차**  
   1. **첨부 파일 삭제 예약**  
- FileRepository.findAllByAnnouncementId() 함수를 호출해 해당 공지에 연결된 모든 파일을 조회한다.  
- 이후 각 파일의 isDeleted 필드를 true로 설정하고, 공지 외래키를 null로 변경하여 논리적 삭제를 수행한다.  
  2. **댓글 삭제 처리**  
- CommentRepository.findAllByAnnouncement\_Id() 함수를 호출해 해당 공지에 달린 모든 댓글을 조회하고 삭제 처리한다.  
  3. **공지 삭제**  
- 모든 관련 데이터 정리가 완료되면, 

  AnnouncementRepository.delete()를 통해 공지를 테이블에서 실제 삭제한다. 

6. **응답 반환**  
- 공지 삭제가 정상적으로 완료되면, 컨트롤러는 HTTP 200 OK 코드를 클라이언트에 반환한다.

4.17.공지 상세 조회

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2017.png)
그림 \# sequence 17.png

위 그림은 스터디 내 특정 공지의 상세 조회 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다.

1. **클라이언트 요청**  
- 사용자가 특정 공지의 상세 정보를 조회하면, 클라이언트는 서버로 공지 상세 조회 요청을 전송한다.  
2. **Controller 계층 처리**  
- 서버는 컨트롤러의 getAnnouncementDetail() 메서드를 호출하여 요청을 처리한다.  
- 컨트롤러는 공지 상세 데이터를 가져오기 위해 AnnouncementService의 getAnnouncementDetail() 함수를 호출하며, studyId, announcementId,userId를 인수로 전달한다.  
3. **Service 계층 검증 단계**  
   1. **그룹원 검증**   
- GroupService의 memberValidation() 메서드를 호출해 요청자가 해당 스터디의 그룹원인지 확인한다..  
- 그룹원이 아닐 경우 예외가 발생하며, 400 에러 코드가 반환된다.  
4. **공지 및 관련 데이터 조회**   
- 검증이 통과되면, 다음 순서로 공지와 관련 데이터를 조회한다.  
1. **공지 데이터 조회**  
- AnnouncementRepository.findByIdAndStudyId()를 호출해 공지 ID와 스터디 ID가 일치하는 공지 데이터를 조회한다.  
2. **작성자 정보 조회**  
- 공지 작성자의 정보를 가져오기 위해 UserService.getMyProfile()을 호출한다. 이 때 작성자의 닉네임, 프로필 이미지 URL, 역할 등 메타 데이터를 가져온다.   
3. **댓글 조회**  
- CommentRepository.findAllByAnnouncement\_Id() 메서를 호출해 해당 공지에 작성된 모든 댓글을 조회한다.  
- 조회된 댓글에서 댓글 ID, 작성자 이름, 작성자 프로필 URL, 내용, 작성 날짜를 추출한다.  
4. **첨부파일 조회**  
- FileRepository.findAllByAnnouncement\_Id()를 호출하여 공지에 첨부된 모든 파일을 조회한다.  
- 파일 데이터에서 파일ID, 파일 이름을 추출하고 S3를 통해 원본 파일에 대한 URL을 추출한다.

5\. **응답 DTO 생성 및 반환**

- 조회된 공지, 작성자, 댓글, 파일 정보를 바탕으로 하나의 공지 상세 응답 DTO를 구성하여 컨트롤러로 반환한다.

6\. **응답 반환**

- 컨트롤러는 서비스 계층에서 생성된 DTO를 HTTP 200 OK 코드와 함께 클라이언트에 응답 본문으로 전달한다.

4.18.공지 댓글 달기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2018.png)
그림 \# sequence 18.png

위 그림은 스터디 내 특정 공지에 댓글을 작성하는 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다.

1. **클라이언트 요청**  
- 사용자가 특정 공지에 댓글을 작성하면, 클라이언트는 서버로 댓글 작성 요청을 전송한다.  
2. **Controller 계층 처리**  
- 서버는 컨트롤러의 addComment() 메서드를 호출하여 요청을 처리한다.  
- 컨트롤러는 댓글 생성을 위해 AnnouncementService.addComment() 함수를 호출하며,  studyId, announcementId, userId, 댓글 내용을 인수로 전달한다.  
3. **Service 계층 검증 단계**  
   1. **그룹원 검증**   
- GroupService의 memberValidation() 메서드를 호출해 요청자가 해당 스터디의 그룹원인지 확인한다..  
- 그룹원이 아닐 경우 예외가 발생하며, 400 에러 코드가 반환된다.  
  2. **공지 존재 여부 검증**  
- AnnouncementRepository.findByIdAndStudyId() 함수를 호출하여 공지 ID와 스터디 ID가 일치하는 공지 데이터를 조회한다.  
- 해당 공지가 존재하지 않을 경우, 404 에러 코드를 반환한다.  
4. **댓글 생성 및 저장**  
- 공지가 존재하면, 요청 받은 댓글 내용을 기반으로 새로운 댓글 객체를 생성한다.  
- 이 때 앞서 조회한 공지 엔티티와 스터디 멤버 엔티티를 외래키로 설정한다.  
- 생성된 댓글 객체는 CommentRepository.save() 함수를 통해 DB에 저장된다.  
5. **응답 반환**  
- 컨트롤러는 댓글 작성 요청이 정상적으로 처리된 경우 HTTP 201 Created 코드를 클라이언트에 반환한다.

4.19. 자료 목록 조회

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2019.png)
그림 \# sequence 19.png

위 그림은 스터디 내 자료 목록 조회 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다.

1. **클라이언트 요청**  
- 사용자가 특정 스터디의 자료 목록을 조회하면, 클라이언트는 서버로 자료 목록 조회 요청을 전송한다.

2. **Controller 계층 처리**  
- 서버는 컨트롤러의 getResources() 메서드를 호출하여 요청을 처리한다.  
- 컨트롤러는 자료 목록 조회를 위해 resourceService.getResources() 함수를 호출하며, studyId와 userId를 인수로 전달한다.

3. **Service 계층 검증 단계**  
   1.  **그룹원 검증**  
- GroupService.memberValidation() 메서드를 호출해 요청자가 해당 스터디의 그룹원인지 검증한다.  
- 그룹원이 아닐 경우 예외가 발생하며, 400 에러 코드가 반환된다.

4. **자료 목록 조회**   
- 검증이 통과되면, resourceRepository.findAllByStudyId() 함수를 호출하여 특정 스터디에 등록된 모든 자료 목록을 조회한다.

5. **작성자 정보 및 DTO 생성**  
-  조회된 각 자료를 순회하면서 UserService.getMyProfile() 함수를 호출하여 작성자의 메타데이터를 조회하여  nickname(작성자명)을 추출한다.  
- 각 자료에 대해 자료 제목, 생성 날짜를 추출하고 앞서 추출한 nickname과 결합해 DTO를 만든다.  
- 생성된 DTO들을 모아 DTO List를 구성한 뒤 컨트롤러로 반환한다.  
6. **응답 반환**  
- 컨트롤러는 서비스 계층에서 생성된 DTO 리스트를 HTTP 200 OK 코드와 함께 클라이언트에 반환한다.

4.20. 자료 생성

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2020.png)
그림 \# sequence 20.png

위 그림은 스터디 내 자료 생성 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다.

1. **클라이언트 요청**  
- 사용자가 새로운 자료를 업로드하면, 클라이언트는 서버로 자료 생성 요청을 전송한다.  
2. **Controller 계층 처리**  
- 서버는 컨트롤러의 createResource() 메서드를 호출하여 요청을 처리한다.  
- 컨트롤러는 자료 생성을 위해 ResourceService.createResource() 메서드를 호출하며, studyId, userId, 자료 정보를 인수로 전달한다.

3. **Service 계층 검증 단계**   
   1.  **그룹원 검증**  
- groupService.memberValidation() 함수를 호출해 요청자가 해당 스터디의 그룹원인지 검증한다.  
- 그룹원이 아닐 경우 예외가 발생하며, 400 에러 코드가 반환된다.  
4. **자료 생성 및 저장 처리**  
- 검증이 통과되면, 전달받은 자료 정보를 기반으로 새로운 Resource 객체를 생성한다. 이후 ResourceRepository.save()  함수를 호출해 자료를 DB 테이블에 저장한다.  
5. **첨부파일 처리**  
   1. **첨부파일 존재 시**   
- 자료 생성 요청에 첨부파일이 포함되어 있다면, 각 파일에 대해 파일 메타데이터를 DB에 저장하고 실제 파일 데이터는 AWS S3 스토리지에 업로드한다.  
  2. **S3 업로드 실패 시 예외 처리**  
- 파일 업로드 과정에서 오류가 발생하면, 시스템은 HTTP 500 서버 내부 에러 코드를 반환한다.  
6. **응답 반환**  
- 모든 과정이 정상적으로 완료되면, 컨트롤러는 HTTP 201 Created 코드를 클라이언트에 반환한다.

4.21. 자료 수정

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2021.png)
그림 \# sequence 21.png

위 그림은 스터디 내 자료 수정 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다.

1. **클라이언트 요청**  
- 사용자가 스터디 내 자료를 수정하면, 클라이언트는 서버로 자료 수정 요청을 전송한다.  
2. **Controller 계층 처리**   
- 서버는 컨트롤러의 updateResource() 메서드를 호출하여 요청을 처리한다.  
- 컨트롤러는 자료 수정을 위해 resourceService.updateResource() 함수를 호출하며, studyId, resourceId, userId, 수정 정보를 인수로 전달한다.  
3. **Service 계층 검증 단계**   
   1.  **그룹원 검증**  
- groupService.memberValidation() 함수를 호출해 요청자가 해당 스터디의 그룹원인지 검증한다.  
- 그룹원이 아닐 경우 예외가 발생하며, 400 에러 코드가 반환된다.  
  2. **자료 존재 여부 검증**  
- resourceRepository.findById()를 호출하여 해당 자료가 실제로 존재하는지 확인한다.  
- 자료가 존재하지 않을 경우 예외가 발생하며, 404 에러 코드가 반환된다.  
  3. **작성자 일치 검증**  
- 자료가 존재한다면, 해당 자료의 작성자와 요청 사용자의 study id를 비교하여 수정 권한이 있는지 확인한다.  
- 작성자가 일치하지 않을 경우 예외가 발생하며, 404 에러 코드가 반환된다.  
4. **자료 수정 및 파일 처리**  
   1. **자료 내용 수정**  
- 매개변수로 전달된 수정 정보를 기존 자료 객체에 반영하고 변경된 내용을 DB에 저장한다.  
  2. **기존 파일 삭제 처리**  
- 수정 시 기존 파일을 삭제해야 하는 경우,  fileRepository.findAllById()로 삭제 대상 파일을 조회한 뒤 각 파일의 isDeleted 필드를 true로 설정하고 자료에 대한 외래키를 null로 변경하여 논리적 삭제를 수행한다.  
  3. **새 파일 추가 처리**  
- 새로운 파일이 추가될 경우, 해당 파일의 메타데이터를 DB에 저장하고 실제 파일 데이터는 AWS S3 스토리지에 업로드한다.  
5. **응답 반환**  
- 모든 수정 작업이 정상적으로 완료되면, 컨트롤러는 HTTP 200 OK 코드를 클라이언트에 반환한다. 

4.22. 자료 삭제

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2022.png)
그림 \# sequence 22.png

위 그림은 스터디 내 특정 자료 삭제 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다.

1. **클라이언트 요청**  
- 사용자가 특정 자료를 삭제하면, 클라이언트는 서버로 자료 삭제 요청을 전송한다.  
2. **Controller 계층 처리**  
- 서버는 컨트롤러의 deleteResource() 메서드를 호출하여 요청을 처리한다.  
- 컨트롤러는 자료 삭제를 위해 resourceService.deleteResource() 메서드를 호출하며, studyId, userId, resourceId를 인수로 전달한다.  
3. **Service 계층 검증 단계**   
   1.  **그룹원 검증**  
- groupService.memberValidation() 함수를 호출해 요청자가 해당 스터디의 그룹원인지 검증한다.  
- 그룹원이 아닐 경우 예외가 발생하며, 400 에러 코드가 반환된다.  
  2. **자료 존재 여부 검증**  
- resourceRepository.findById()를 호출하여 해당 자료가 실제로 존재하는지 확인한다.  
- 자료가 존재하지 않을 경우 예외가 발생하며, 404 에러 코드가 반환된다.  
  3. **작성자 일치 검증**  
- 자료가 존재한다면, 해당 자료의 작성자와 요청 사용자의 userId를 비교하여 삭제 권한이 있는지 확인한다.  
- 작성자가 일치하지 않을 경우 예외가 발생하며, 404 에러 코드가 반환된다.  
4. **파일 삭제 처리 및 자료 삭제**  
   1. **첨부 파일 논리적 삭제**  
- FileRepository.findAllByResource\_Id() 메서드를 호출하여 삭제할 자료와 연결된 모든 파일을 조회한다.  
- 각 파일의 isDeleted 필드를 true로 설정하고, 자료 외래키를 null로 변경하여 논리적 삭제를 수행한다.  
  2. **자료 삭제**  
- 파일 삭제 처리가 완료되면, resourceRepository.delete()를 호출하여 자료를 DB에서 삭제한다.  
5. **응답 반환**  
- 모든 절차가 정상적으로 완료되면, 컨트롤러는 HTTP 204 No Content 코드를 클라이언트에 반환한다.

4.23. 자료 상세 데이터 가져오기 

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2023.png)
그림 \# sequence 23.png

위 그림은 스터디 내 특정 자료의 상세 데이터를 조회하는 기능의 동작 흐름을 나타낸 시퀀스 다이어그램이다. 

1. **클라이언트 요청**  
- 사용자가 특정 자료의 상세 정보를 조회하면, 클라이언트는 서버로 자료 상세 조회 요청을 전송한다.  
2. **Controller 계층 처리**  
- 서버는 컨트롤러의 getResourceDetail() 메서드를 호출하여 요청을 처리한다.  
- 컨트롤러는 자료 상세 조회를 위해 resourceService.getResourceDetail() 함수를 호출하며, studyId, userId, resourceId를 인수로 전달한다.  
3. **Service 계층 검증 단계**  
   1.  **그룹원 검증**  
- groupService.memberValidation() 함수를 호출해 요청자가 해당 스터디의 그룹원인지 검증한다.  
- 그룹원이 아닐 경우 예외가 발생하며, 400 에러 코드가 반환된다.  
4. **자료 조회 및 검증**  
- 검증이 통과되면, ResourceRepository.findByIdAndStudyId() 메서드를 호출하여 자료 ID와 스터디 ID가 모두 일치하는 자료를 조회한다.  
- 자료가 존재하지 않을 경우 예외가 발생하며, 404 에러 코드가 반환된다.

5. **저자 및 파일 정보 조회**  
   1. **저자 정보 조회**  
- 조회된 Resource 객체를 기반으로, UserService.getMyProfile() 메서드를 호출하여 저자의 메타데이터를 가져온다.  
  2. **첨부 파일 조회**  
- fileRepository.findAllByResource\_Id() 함수를 호출하여 해당 자료에 연결된 모든 첨부 파일 목록을 조회한다.  
- 파일 데이터에서는 파일 이름, 파일 URL, 파일 ID 등을 추출한다..  
6. **응답 DTO 생성 및 반환**  
- 조회된 자료, 저자 정보, 첨부 파일 정보를 기반으로 자료 제목, 내용, 저자 닉네임, 프로필 이미지 URL, 자료 생성일, 첨부 파일 리스트를 포함하는 DTO를 생성한다.  
- 이 DTO는 컨트롤러로 반환된다.  
7. **응답 반환**  
- 컨트롤러는 서비스 계층에서 전달된 DTO를 HTTP 200 OK 코드와 함께 클라이언트에 반환한다. 

4.24 스터디 그룹 찜하기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2024.png)
그림 \# sequence 24

이 시퀀스 다이어그램은 사용자가 특정 '스터디' 항목에 대해 북마크 추가를 요청할 때, Spring MVC 백엔드 내부에서 동작하는 북마크 생성 및 영속화 절차를 단계적으로 나타낸 것입니다.

사용자가 클라이언트(예: 웹 브라우저)에서 '북마크 추가' 버튼을 클릭하면, 이 요청은 인증 정보와 함께 백엔드의 API 엔드포인트로 전송됩니다. 이 시점부터 다이어그램에 표시된 백엔드 내부의 시퀀스가 실행됩니다.

먼저 Actor(사용자)는 StudyBookmarkController에 북마크 추가를 요청합니다(1: addBookmark). StudyBookmarkController는 이 HTTP 요청을 받아, BookmarkService의 addBookmark 메서드를 호출합니다(1.1: addBookmark). 이 과정에서 컨트롤러는 북마크를 생성하는 데 필요한 데이터(예: 인증된 사용자의 식별자, 북마크할 스터디의 식별자)를 서비스 계층으로 전달합니다.

BookmarkService는 실제 비즈니스 로직을 처리하는 핵심 주체입니다. 1.1.1.0부터 1.1.1.3까지의 \<\<create\>\> 메시지들은, 서비스가 전달받은 ID 값들을 바탕으로 실제 데이터베이스와 연결된 User 엔티티와 Study 엔티티를 조회하거나 생성하는 사전 준비 단계로 해석됩니다.

이후 BookmarkService는 BookmarkRepository의 findByUserIdAndStudyId 메서드를 호출하여(1.1.2), 해당 사용자가 해당 스터디를 이미 북마크했는지 확인하는 중복 검사 로직을 수행합니다. BookmarkRepository는 조회 결과를 다시 BookmarkService로 반환합니다(1.1.2.1: bookmark). 이 다이어그램은 정상 처리 흐름(Happy Path)을 가정하고 있으므로, 만약 여기서 기존 북마크가 발견되었을 때 BusinessException을 발생시키는 등의 예외 처리는 생략되어 있습니다.

중복이 없다고 판단되면, BookmarkService는 새로운 Bookmark 엔티티 생성을 시작합니다. 이때 빌더 패턴(Builder Pattern)을 사용하여 객체의 불변성과 가독성을 확보합니다.

이 시퀀스 다이어그램은 엔티티가 build 되는 시점에서 끝나지만(1.1.6), 실제 로직상으로는 이 직후 BookmarkService가 생성된 Bookmark 객체를 BookmarkRepository.save() 메서드(다이어그램에 생략됨)에 전달하여 데이터베이스에 저장한다.

즉, 이 시퀀스 다이어그램은 사용자의 단순한 요청이 백엔드 내부의 Controller, Service, Repository 계층을 거치며 처리되는 흐름을 구체적으로 보여줍니다. 특히 BookmarkService가 데이터 중복 검증 로직과 빌더 패턴을 이용한 신규 엔티티 생성 로직을 모두 담당하는 핵심적인 역할을 수행함을 명확히 나타냅니다.

4.25 스터디 그룹 찜 해제하기   
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2025.png)
그림 \# sequence 25

이 시퀀스 다이어그램은 사용자가 특정 '스터디' 항목에 대해 북마크 삭제를 요청할 때, Spring MVC 백엔드 내부에서 동작하는 북마크 조회 및 삭제 절차를 단계적으로 나타낸 것입니다.

사용자가 클라이언트(예: 웹 브라우저)에서 '북마크 삭제' 버튼을 클릭하면, 이 요청은 인증 정보와 함께 백엔드의 API 엔드포인트로 전송됩니다. 이 시점부터 다이어그램에 표시된 백엔드 내부의 시퀀스가 실행됩니다.

먼저 Actor(사용자)는 StudyBookmarkController에 북마크 삭제를 요청합니다(1: removeBookmark). StudyBookmarkController는 이 HTTP 요청을 받아, BookmarkService의 removeBookmark 메서드를 호출합니다(1.1: removeBookmark). 이 과정에서 컨트롤러는 북마크를 삭제하는 데 필요한 데이터(예: 인증된 사용자의 식별자, 북마크를 해제할 스터디의 식별자)를 서비스 계층으로 전달합니다.

BookmarkService는 실제 비즈니스 로직을 처리하는 핵심 주체입니다. 1.1.1.0부터 1.1.1.3까지의 \<\<create\>\> 메시지들은, 서비스가 전달받은 ID 값들을 바탕으로 실제 데이터베이스와 연결된 User 엔티티와 Study 엔티티를 조회하는 사전 준비 단계로 해석됩니다.

이후 BookmarkService는 BookmarkRepository의 findByUserIdAndStudyId 메서드를 호출하여(1.1.2), 삭제할 대상 북마크가 존재하는지 확인하는 로직을 수행합니다. BookmarkRepository는 조회 결과를 다시 BookmarkService로 반환합니다(1.1.2.1). 이 다이어그램은 정상 처리 흐름(Happy Path)을 가정하고 있으므로, 만약 여기서 삭제할 북마크를 찾지 못했을 때(결과가 null일 때) BusinessException을 발생시키는 등의 예외 처리는 생략되어 있습니다.

이 시퀀스 다이어그램은 북마크를 조회한 직후(1.1.2.1)의 \<\<create\>\> 메시지(1.1.2.1.1)에서 끝나지만, 이는 삭제 로직을 표현하려다 잘못 표기되었거나(예: '\<\<delete\>\>'여야 함) 핵심 로직이 생략된 것으로 보입니다. 실제 로직상으로는 이 직후 BookmarkService가 조회한 Bookmark 객체를 BookmarkRepository.delete() 메서드(다이어그램에 생략됨)에 전달하여 데이터베이스에서 삭제하는 단계가 반드시 뒤따라야 합니다.

즉, 이 시퀀스 다이어그램은 사용자의 단순한 요청이 백엔드 내부의 Controller, Service, Repository 계층을 거치며 처리되는 흐름을 구체적으로 보여줍니다. 특히 BookmarkService가 삭제할 엔티티를 먼저 정확히 조회하고, 이후 삭제 로직을 호출하는(비록 다이어그램에서는 생략되었지만) 핵심적인 역할을 수행함을 명확히 나타냅니다.

4.26 스터디 그룹 지원서 제출하기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2026.png)
그림 \# sequence 26

이 시퀀스 다이어그램은 사용자가 특정 '스터디'에 참여 신청(지원)을 할 때, Spring MVC 백엔드 내부에서 동작하는 신청 처리 및 알림 발송 절차를 단계적으로 나타낸 것입니다.

사용자가 클라이언트에서 '신청하기' 버튼을 클릭하면, 이 요청은 Actor(사용자)로부터 ApplicationController로 전송됩니다(1: submitApplication). ApplicationController는 이 HTTP 요청을 받아, ApplicationService의 submitApplication 메서드를 호출합니다(1.1: submitApplication). 이 과정에서 컨트롤러는 신청에 필요한 데이터(예: 인증된 사용자 정보, 대상 스터디 식별자)를 서비스 계층으로 전달합니다.

ApplicationService는 실제 비즈니스 로직을 처리하는 핵심 주체입니다. 먼저, 1.1.1.0부터 1.1.1.1까지의 \<\<create\>\> 메시지들을 통해 사전 준비(사용자 정보 조회 등)를 수행합니다. 이후, StudyMemberRepository의 findByStudyIdAndUserIdAndStatus 메서드를 호출하여(1.1.2), 해당 사용자가 이미 스터디 멤버인지 확인하는 1차 중복 검사를 수행합니다. 다이어그램의 \[alt\] 블록(1.1.3)은 이 멤버 상태에 따른 분기 처리를 암시합니다.

다음으로, ApplicationRepository의 findByUserIdAndStudy 메서드를 호출하여(1.1.4), 사용자가 동일한 스터디에 이미 지원한 내역이 있는지 확인하는 2차 중복 검사를 수행합니다. 또 다른 \[alt\] 블록(1.1.4.1.1)은 기존 신청의 상태(예: REJECTED)에 따른 분기 로직이 있음을 보여줍니다.

모든 중복 및 조건 검사를 통과했다고 판단되면(Happy Path), ApplicationService는 새로운 Application 엔티티 생성을 시작합니다. 이때 빌더 패턴(Builder Pattern)을 사용합니다. 1.1.5: builder를 통해 ApplicationBuilder 인스턴스를 가져온 뒤, study(1.1.7), participant(1.1.8) 등 필요한 정보를 설정하고, 1.1.9: build를 호출하여 최종 Application 엔티티 인스턴스를 생성합니다.

신청 엔티티가 생성된 후, 서비스는 이어서 1.1.10: sendNewApplicationNotification을 호출하여 NotificationService에 알림 발송을 요청합니다. NotificationService는 알림을 보낼 대상(스터디 관리자 등)을 찾기 위해 StudyMemberRepository의 findByStudyIdAndRole 메서드를 호출합니다(1.1.10.1). 알림 대상을 찾은 후, NotificationService 역시 빌더 패턴을 사용하여 Notification 객체 생성을 시작합니다(1.1.10.2). study, actor, audienceType, type, followStudy 등 알림에 필요한 각종 정보를 설정한 뒤(1.1.10.3 \~ 1.1.10.7), 1.1.10.8: build를 호출하여 최종 Notification 객체를 생성합니다.

이 시퀀스 다이어그램은 Notification 객체가 build 되는 시점에서 끝나지만, 실제 로직상으로는 이 직후 두 가지 중요한 단계가 생략되어 있습니다.ApplicationService가 1.1.9에서 생성한 Application 객체를 ApplicationRepository.save()를 통해 데이터베이스에 저장해야 합니다.NotificationService가 1.1.10.8에서 생성한 Notification 객체를 실제로 발송하거나 저장하는(예: NotificationRepository.save() 또는 이벤트 발행) 로직이 뒤따라야 합니다.

즉, 이 다이어그램은 사용자의 '스터디 신청' 요청이 백엔드 내부의 여러 서비스(ApplicationService, NotificationService)와 리포지토리(StudyMemberRepository, ApplicationRepository)를 거치며, 데이터 검증, 신청 엔티티 생성, 그리고 관련자에게 알림을 보내기 위한 알림 객체 생성에 이르는 복잡한 흐름을 구체적으로 보여줍니다.

4.27 스터디 그룹 생성하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2027.png)
그림 \# sequence 27

이 시퀀스 다이어그램은 사용자가 신규 스터디 생성을 요청할 때, Spring MVC 백엔드 내부에서 동작하는 스터디 및 연관 엔티티 생성 절차를 단계적으로 나타낸 것입니다.

사용자가 클라이언트에서 '스터디 만들기' 폼을 제출하면, 이 요청은 Actor(사용자)로부터 StudyController로 전송됩니다(1: createStudy). StudyController는 이 HTTP 요청을 받아, StudyService의 createStudy 메서드를 호출합니다(1.1: createStudy). 이 과정에서 컨트롤러는 스터디 생성에 필요한 폼 데이터(제목, 설명, 주소, 카테고리 등)와 인증된 사용자 정보를 서비스 계층으로 전달합니다.

StudyService는 실제 비즈니스 로직을 처리하는 핵심 주체입니다. 먼저 1.1.1.0부터 1.1.1.1까지의 \<\<create\>\> 메시지를 통해 사전 준비(요청을 보낸 사용자 정보 조회 등)를 수행합니다. 이후 서비스는 빌더 패턴(Builder Pattern)을 사용하여 스터디 생성에 필요한 여러 엔티티 객체들을 순차적으로 생성합니다.

Study 엔티티 생성: 1.1.2: builder를 호출하고 maxMemberCount(1.1.3), currentStatus(1.1.4) 등 스터디의 기본 정보를 설정한 뒤 1.1.5: build를 호출하여 Study 객체를 생성합니다.Address 엔티티 생성: 1.1.6: builder를 호출하고 스터디 지역 정보인 province(1.1.7), city(1.1.8)를 설정한 뒤 1.1.9: build로 Address 객체를 생성합니다.StudyProfile 엔티티 생성: 1.1.10: builder를 호출하고, 앞서 생성한 Study 객체(1.1.11), 폼으로 전달받은 title(1.1.12), description(1.1.14), 그리고 Address 객체(1.1.15) 등을 모두 설정한 뒤 1.1.17: build로 StudyProfile 객체를 생성합니다. 이 객체는 Study와 1:1 관계를 가지는 상세 정보 역할을 합니다.StudyMember 엔티티 생성: 마지막으로, 스터디를 생성한 사용자를 '스터디장(OWNER 또는 LEADER)'으로 자동 등록하기 위한 StudyMember 객체를 생성합니다. 1.1.18: builder를 호출하고, 생성된 Study 객체(1.1.19), 요청 사용자(1.1.20), role(1.1.21), status(1.1.22)를 설정한 뒤 1.1.23: build로 객체를 생성합니다.이 시퀀스 다이어그램은 스터디 생성에 필요한 모든 연관 객체(Study, Address, StudyProfile, StudyMember)가 메모리상에서 build 되는 시점에서 끝납니다.

실제 로직상으로는 이 직후, StudyService가 생성된 엔티티들을(예: Study, StudyProfile, StudyMember) 각 Repository의 save 메서드(다이어그램에 생략됨)에 전달하여 데이터베이스에 영속화(저장)하는 단계가 반드시 뒤따라야 합니다. 이 과정은 여러 엔티티를 동시에 저장해야 하므로 아마도 하나의 트랜잭션(Transaction)으로 함께 묶여 처리될 것입니다.

즉, 이 다이어그램은 '스터디 생성'이라는 하나의 요청이 백엔드 내부에서 관련된 여러 도메인 엔티티들을 빌더 패턴을 통해 일관되게 생성하고 조립하는 복잡한 과정을 구체적으로 보여줍니다.

4.28 그룹 프로필 정보 조회하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2028.png)
그림 \# sequence 28

이 시퀀스 다이어그램은 사용자가 특정 '스터디'의 상세 프로필 조회를 요청할 때, Spring MVC 백엔드 내부에서 동작하는 데이터 집계 및 응답 생성 절차를 단계적으로 나타낸 것입니다.

사용자가 클라이언트에서 특정 스터디 페이지에 진입하면, 이 요청은 Actor(사용자)로부터 StudyController로 전송됩니다(1: getStudyProfile). StudyController는 이 HTTP 요청을 받아, StudyService의 getStudyProfile 메서드를 호출합니다(1.1: getStudyProfile). 이 과정에서 컨트롤러는 조회할 스터디의 식별자(ID)와 인증된 사용자 정보를 서비스 계층으로 전달합니다.

StudyService는 실제 비즈니스 로직을 처리하는 핵심 주체로서, 여러 리포지토리에서 데이터를 조합(Aggregate)하는 역할을 수행합니다. 먼저 StudyProfileRepository에서 1.1.2: findById를 호출하여 스터디의 핵심 프로필 정보를 조회하고, 이어서 StudyMemberRepository의 1.1.3: findByStudy를 호출하여 해당 스터디에 속한 멤버 목록을 조회합니다. 동시에 UserProfileRepository의 1.1.4: findById를 호출하여 현재 요청을 보낸 *사용자*의 프로필 정보도 가져옵니다.

\[alt\]로 표시된 1.1.5 분기 블록은 리더의 프로필 이미지 URL을 처리하는 로직을 보여줍니다. 만약 조회된 리더 프로필에 이미지 URL이 존재한다면 S3Uploader의 getFileUrl 메서드를 호출하여(1.1.5.1), 저장된 파일 키(key)를 실제 접근 가능한 URL(예: Pre-signed URL)로 변환하는 작업을 수행합니다.

데이터 집계는 계속됩니다. StudyMemberRepository의 1.1.6: countByStudyAndRole을 호출하여 특정 역할(예: 참여 승인된 멤버)의 인원수를 계산하고, ApplicationRepository의 1.1.7: countByStudyAndRole을 호출하여 현재 '신청 중인(Pending)' 지원자의 수를 계산합니다. 또한 1.1.8: findByStudyAndRoleAndStatus를 호출하여 스터디의 '리더(Leader)' 정보도 별도로 조회합니다.

StudyService는 위에서 수집한 모든 데이터(리더 정보, S3 이미지 URL 등)를 사용하여 먼저 LeaderProfile 객체를 생성합니다(1.1.9: \<\<create\>\>). 최종적으로, 스터디 프로필 정보, 멤버 수, 신청자 수, 리더 프로필 등 모든 데이터를 취합하여 클라이언트에게 반환할 GetStudyProfileResponse라는 DTO(Data Transfer Object)를 생성합니다(1.1.10: \<\<create\>\>).

이 시퀀스 다이어그램은 GetStudyProfileResponse 객체가 생성되는 시점에서 끝납니다. 실제 로직상으로는 이 직후, StudyService가 생성된 응답 객체를 StudyController로 반환하고, 컨트롤러는 이를 Actor(사용자)에게 HTTP 응답으로 전송하며 흐름이 종료됩니다.

즉, 이 다이어그램은 '스터디 상세 조회'라는 단순한 요청을 처리하기 위해, 백엔드 내부에서 여러 리포지토리와 외부 서비스(S3Uploader)를 유기적으로 호출하여 필요한 모든 데이터를 집계하고, 이를 단일 응답 DTO로 조립하는 복잡한 '읽기(Read)' 과정을 구체적으로 보여줍니다.

4.29 그룹 정보 수정하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2029.png)
그림 \# sequence 29

이 시퀀스 다이어그램은 사용자가 기존 '스터디'의 프로필 수정을 요청할 때, Spring MVC 백엔드 내부에서 동작하는 데이터 검증 및 업데이트 절차를 단계적으로 나타낸 것입니다.

흐름은 Actor(사용자)가 StudyController로 1: updateStudyProfile 요청을 보내면서 시작됩니다. StudyController는 이 HTTP 요청을 받아, 수정할 데이터와 함께 StudyService의 1.1: updateStudyProfile 메서드를 호출합니다.

StudyService는 실제 비즈니스 로직을 처리하는 핵심 주체로서, 수정 작업에 앞서 중요한 검증(Validation) 절차를 수행합니다. 가장 먼저, "이 요청을 보낸 사용자가 스터디를 수정할 권한이 있는가?"를 확인합니다. 서비스는 1.1.1: findByStudyIdAndRole을 호출하여 StudyMemberRepository로부터 해당 스터디의 '리더(Leader)' 정보를 조회합니다. 다이어그램의 첫 번째 \[alt\] 블록(1.1.2)은 바로 이 권한 검증 로직을 나타냅니다. 즉, 조회된 리더의 사용자 ID와 현재 요청을 보낸 사용자의 ID(requestUserId)가 일치하는지 비교합니다. 만약 일치하지 않는다면, 이 흐름은 중단되고 BusinessException(비록 다이어그램에서 직접 호출되진 않았지만)이 발생할 것입니다.

권한이 확인되면, 서비스는 1.1.4: findById를 호출하여 StudyProfileRepository에서 수정할 대상이 되는 StudyProfile 엔티티를 조회합니다.

엔티티에 수정 데이터를 바로 적용하기 전에, 또 다른 비즈니스 규칙 검증이 수행됩니다. 서비스는 1.1.5: countByStudyIdAndStatus를 호출하여 StudyMemberRepository로부터 현재 스터디의 "활동 중인 멤버 수"를 가져옵니다. 두 번째 \[alt\] 블록(1.1.6)은 이 값을 사용자의 요청 값과 비교합니다. 만약 사용자가 "최대 인원수"를 "현재 인원수"보다 적게 설정하려 한다면, 이는 비즈니스 규칙에 어긋나므로(request.getMemberCount() \< currentMemberCount) 이 역시 예외 처리가 필요합니다.

모든 권한 검증과 비즈니스 규칙 검증을 통과한 후에야 비로소 실제 업데이트가 발생합니다. 서비스는 1.1.7: updateMaxMemberCount를 호출하여 Study 엔티티의 최대 인원수를 변경하고, 1.1.9: update를 호출하여 StudyProfile 엔티티의 나머지 정보(제목, 설명 등)를 변경합니다.

이 시퀀스 다이어그램은 Study와 StudyProfile 같은 도메인 엔티티가 메모리상에서 수정되는 시점에서 끝납니다. 실제 로직상으로는 이 직후, StudyService가 변경된 엔티티들을 각 Repository의 save 메서드(다이어그램에 생략됨)에 전달하여 데이터베이스에 (저장)하는 단계가 반드시 뒤따라야 합니다.

즉, 이 다이어그램은 '업데이트' 요청이 단순히 데이터를 덮어쓰는 것이 아니라, 권한 검증(Authorization)과 비즈니스 규칙 검증(Validation)이라는 두 개의 중요한 관문을 통과해야만 실제 데이터 수정이 이루어지는 복잡한 과정임을 구체적으로 보여줍니다.

4.30 그룹 삭제하기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2030.png)
그림 \# sequence 30

이 시퀀스 다이어그램은 사용자가 자신이 생성한 '스터디'를 완전히 삭제할 때, Spring MVC 백엔드 내부에서 동작하는 데이터 검증 및 연쇄 삭제(Cascade Delete) 절차를 단계적으로 나타낸 것입니다. 이는 단순한 단일 엔티티 삭제가 아닌, 스터디와 관련된 모든 하위 데이터를 정리하는 매우 복잡하고 중요한 작업입니다.

흐름은 Actor(사용자)가 StudyController로 1: deleteStudy 요청을 보내면서 시작됩니다. StudyController는 이 HTTP 요청을 받아, 삭제할 스터디의 식별자와 사용자 정보를 StudyService의 1.1: deleteStudy 메서드로 전달합니다.

StudyService는 실제 비즈니스 로직을 처리하는 핵심 주체로서, 삭제 작업에 앞서 치명적인 권한 검증(Authorization)을 먼저 수행합니다. 서비스는 1.1.1: findByStudyIdAndRole을 호출하여 StudyMemberRepository로부터 해당 스터디의 '리더(Leader)' 정보를 조회합니다. 다이어그램의 첫 번째 \[alt\] 블록(1.1.2)은 이 검증 로직을 명확히 보여줍니다. 즉, 조회된 리더의 사용자 ID가 현재 요청을 보낸 사용자의 ID(requestUserId)와 일치하는지 엄격하게 비교합니다. 만약 일치하지 않는다면, 이 흐름은 즉시 중단되고 BusinessException(예외)이 발생할 것입니다.

권한이 확인되면, 서비스는 스터디와 관련된 모든 종속 데이터를 순차적으로 삭제하는 대규모 정리 작업을 시작합니다. 먼저 ApplicationRepository의 1.1.3: deleteByStudyId를 호출하여 이 스터디에 접수된 모든 '참여 신청' 내역을 삭제합니다. 이어서 1.1.4: deleteByStudyId를 호출하여 StudyProfileRepository에서 '스터디 프로필' 정보를 삭제합니다.

다음으로, 1.1.5: findByStudyId를 호출하여 ResourceRepository에서 스터디에 업로드된 '모든 리소스(파일)' 목록을 조회합니다. 그리고 조회된 리소스를 삭제(1.1.5.1: delete)할 때, 1.1.5.1.1: deleteStudyDirectory를 통해 S3Uploader를 호출하여 데이터베이스 레코드뿐만 아니라 S3와 같은 외부 스토리지의 실제 파일 디렉토리까지 삭제합니다.

이어서 스터디의 '과제' 관련 데이터를 정리합니다. 1.1.6: findByStudyId로 AssignmentRepository에서 모든 과제를 조회한 뒤, 연관된 '숙제 제출물'(1.1.6.1: deleteByAssignment, HomeworkRepository)과 '피드백'(1.1.6.2: deleteByAssignment, FeedbackRepository)을 먼저 삭제하고, 마지막으로 '과제' 자체(1.1.6.3: deleteByAssignment)를 삭제합니다.

그 후, 시스템에 남아있는 각종 흔적들을 제거합니다. NotificationRepository를 여러 번 호출하여(1.1.7, 1.1.8, 1.1.11) 공지사항, 숙제, 스터디 관련 '알림'들을 모두 삭제합니다. ChatMessageRepository의 1.1.9: deleteByStudyId를 호출하여 스터디 '채팅 메시지'를 삭제하고, StudyLogRepository의 1.1.10: deleteByStudyId를 호출하여 '활동 로그'를 삭제합니다.

모든 하위 데이터가 정리된 후, StudyMemberRepository의 1.1.12: deleteByStudyId를 호출하여 스터디에 속한 '모든 멤버' 정보를 삭제합니다. (1.1.13: deleteByStudyId 호출은 1.1.4와 중복되는 것으로 보이나, 아마도 확실한 삭제를 보장하기 위한 단계일 수 있습니다.)

이 모든 종속 데이터가 삭제된 것이 확인되면, 마지막으로 1.1.14: deleteByStudyId가 StudyService(또는 내부의 StudyRepository)로 호출되어 핵심 엔티티인 '스터디' 자체를 데이터베이스에서 삭제하며 모든 절차가 마무리됩니다.

즉, 이 다이어그램은 '스터디 삭제'라는 하나의 요청이 백엔드 내부에서 엄격한 권한 검증을 거친 뒤, 수많은 테이블과 외부 스토리지(S3)에 걸쳐있는 모든 관련 데이터를 연쇄적으로 삭제하는 복잡한 트랜잭션 과정을 구체적으로 보여줍니다.

4.31 그룹 탈퇴하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2031.png)
그림 \# sequence 31

이 시퀀스 다이어그램은 사용자가 참여 중인 '스터디'에서 '탈퇴'를 요청할 때, Spring MVC 백엔드 내부에서 동작하는 데이터 검증 및 상태 변경 절차를 단계적으로 나타낸 것입니다.

흐름은 Actor(사용자)가 StudyMemberController로 1: leaveStudy 요청을 보내면서 시작됩니다. StudyMemberController는 이 HTTP 요청을 받아, 탈퇴 처리를 위해 StudyMemberService의 1.1: leaveStudy 메서드를 호출합니다.

StudyMemberService는 실제 비즈니스 로직을 처리하는 핵심 주체입니다. 먼저, 서비스는 1.1.1: findByStudyIdAndUserIdAndStatus를 호출하여 StudyMemberRepository로부터 해당 스터디와 사용자, 그리고 현재 '활동 중'인 상태의 'StudyMember' 엔티티를 정확히 조회합니다.

엔티티를 조회한 후, 가장 중요한 비즈니스 규칙 검증이 수행됩니다. 다이어그램의 \[alt\] 블록(1.1.2)은 이 검증 로직을 명확히 보여줍니다. 서비스는 조회된 studyMember.getRole()이 'StudyRole.LEADER'와 같은지 비교합니다. 만약 탈퇴를 시도하는 사용자가 해당 스터디의 '리더'라면, 시스템은 1.1.2: \<\<create\>\>를 통해 BusinessException(비즈니스 예외)을 생성(또는 발생)시킵니다. 이는 "리더는 스터디를 삭제하거나 권한을 위임하지 않고서는 임의로 탈퇴할 수 없다"는 중요한 비즈니스 규칙을 강제하는 것입니다.

만약 \[alt\] 블록의 조건을 통과한다면, 즉 탈퇴 요청자가 리더가 아닌 일반 멤버라면, 흐름은 1.1.3: updateStatus로 이어집니다. 서비스는 조회한 StudyMember 엔티티 객체의 상태를(예: 'ACTIVE'에서 'LEFT' 또는 'INACTIVE'로) 변경합니다.

이 시퀀스 다이어그램은 엔티티의 상태가 메모리상에서 변경되는 시점에서 끝납니다. 실제 로직상으로는 이 직후, StudyMemberService가 상태가 변경된 StudyMember 객체를 StudyMemberRepository.save() 메서드(다이어그램에 생략됨)에 전달하여 변경된 상태를 데이터베이스에 영속화(저장)하는 단계가 반드시 뒤따라야 합니다.

즉, 이 다이어그램은 '스터디 탈퇴'가 단순한 데이터 삭제(Delete)가 아니라, "리더는 탈퇴할 수 없다"는 핵심 비즈니스 규칙 검증을 통과한 후에 이루어지는 '상태 변경(Update)' 작업임을 구체적으로 보여줍니다.

4.32 그룹원 강퇴하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2032.png)
그림 \# sequence 32

이 시퀀스 다이어그램은 사용자가(스터디 리더로 추정) 특정 '스터디'에서 다른 멤버를 강퇴(Expel)시킬 때, Spring MVC 백엔드 내부에서 동작하는 권한 검증, 상태 변경, 알림 발송 절차를 단계적으로 나타낸 것입니다.

흐름은 Actor(사용자)가 StudyMemberController로 1: expelMember 요청을 보내면서 시작됩니다. StudyMemberController는 이 HTTP 요청을 받아, 강퇴 처리에 필요한 정보(스터디 ID, 강퇴 대상 유저 ID, 요청자 ID)를 StudyMemberService의 1.1: expelMember 메서드로 전달합니다.

StudyMemberService는 실제 비즈니스 로직을 처리하는 핵심 주체로서, 여러 단계의 엄격한 검증(Validation)을 수행합니다.

권한 검증 (Authority Check): 가장 먼저, "이 요청을 보낸 사용자가 스터디 리더가 맞는가?"를 확인합니다. 서비스는 1.1.1: findByStudyIdAndRole을 호출하여 StudyMemberRepository로부터 해당 스터디의 '리더(Leader)' 정보를 조회합니다. 첫 번째 \[alt\] 블록(1.1.2)이 이 검증 로직을 보여주며, 만약 요청자(requestUserId)가 리더가 아니라면 1.1.2.1: \<\<create\>\>를 통해 BusinessException(비즈니스 예외)을 발생시키고 처리를 중단합니다.

자기 자신 강퇴 방지 (Self-Expel Check): 다음으로, "리더가 자기 자신을 강퇴하려 하는가?"를 확인합니다. 두 번째 \[alt\] 블록(1.1.3)은 강퇴 대상자(targetUserId)와 요청자(requestUserId)가 동일한지 비교합니다. 만약 리더가 자신을 강퇴하려 한다면, 이는 허용되지 않는 동작이므로 1.1.3.1: \<\<create\>\>를 통해 BusinessException을 발생시킵니다.

모든 검증을 통과하면, 서비스는 1.1.4: findByStudyIdAndUserIdAndStatus를 호출하여 StudyMemberRepository에서 강퇴할 대상이 되는 StudyMember 엔티티를 정확히 조회합니다.

엔티티가 성공적으로 조회되면, 서비스는 1.1.5: updateStatus를 호출하여 해당 StudyMember 객체의 상태를(예: 'ACTIVE'에서 'EXPELLED'로) 변경함으로써 강퇴 처리를 수행합니다.

멤버의 상태가 변경된 후, 서비스는 이 사실을 강퇴당한 사용자에게 알리기 위해 1.1.6: sendStudyExpulsionNotification을 호출하여 NotificationService에 알림 발송을 요청합니다. NotificationService는 1.1.6.1: findById를 호출하여 UserProfileRepository에서 강퇴당한 사용자의 프로필 정보를 조회합니다.

마지막으로, NotificationService는 빌더 패턴(Builder Pattern)을 사용해 Notification 객체를 생성합니다. 1.1.6.3: builder를 시작으로 study(1.1.6.4), actor(1.1.6.5), audienceType(1.1.6.6) 등 강퇴 알림에 필요한 모든 정보를 순차적으로 설정한 뒤, 1.1.6.9: build를 호출하여 최종 Notification 객체를 생성합니다.

이 시퀀스 다이어그램은 알림 객체가 생성되는 시점에서 끝납니다. 실제 로직상으로는 이 직후 StudyMemberService가 1.1.5에서 변경한 StudyMember의 상태를 데이터베이스에 저장(save)하고, NotificationService가 생성된 Notification을 발송 또는 저장하는 단계가 뒤따라야 합니다.

즉, 이 다이어그램은 멤버 강퇴가 이중 권한 검증(리더 여부, 셀프 강퇴 여부)을 통과해야만 실행되며, 대상의 상태를 변경하고 당사자에게 알림을 생성하는 일련의 과정을 구체적으로 보여줍니다.

4.33 그룹 지원서 목록 조회하기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2033.png)
그림 \# sequence 33

이 시퀀스 다이어그램은 사용자가(스터디 리더로 추정) 자신이 관리하는 스터디의 '참여 신청 목록 조회'를 요청할 때, Spring MVC 백엔드 내부에서 동작하는 권한 검증, 데이터 조회, 그리고 최종 응답 DTO(Data Transfer Object) 조립 절차를 단계적으로 나타낸 것입니다.

흐름은 Actor(사용자)가 ApplicationController로 1: getApplications 요청을 보내면서 시작됩니다. ApplicationController는 이 HTTP 요청을 받아, 조회할 스터디의 식별자와 요청을 보낸 사용자의 ID를 ApplicationService의 1.1: getApplications 메서드로 전달합니다.

ApplicationService는 실제 비즈니스 로직을 처리하는 핵심 주체로서, 데이터 조회를 수행하기 전에 엄격한 권한 검증(Authorization)을 먼저 실시합니다. 서비스는 1.1.2: findByStudyIdAndRole을 호출하여 StudyMemberRepository로부터 해당 스터디의 '리더(Leader)' 정보를 조회합니다. 다이어그램의 첫 번째 \[alt\] 블록(1.1.3)은 이 검증 로직을 명확히 보여줍니다. 만약 조회된 리더의 ID가 현재 요청을 보낸 사용자(requestUserId)의 ID와 일치하지 않는다면, 시스템은 1.1.3.1: \<\<create\>\>를 통해 BusinessException(비즈니스 예외)을 발생시키고 즉시 처리를 중단합니다.

권한이 성공적으로 확인되면, ApplicationService는 1.1.4: findByStudyId를 호출하여 ApplicationRepository에서 해당 스터디에 접수된 모든 'Application' 엔티티(신청 내역) 목록을 가져옵니다.

다음으로, 서비스는 조회된 각 신청 내역(Application)을 순회하며(다이어그램에 암시됨) 필요한 추가 정보를 조합합니다. 각 신청에 대해 1.1.4.1.1: findByUserId를 호출하여 UserProfileRepository에서 신청자의 상세 프로필 정보를 조회합니다.

프로필 정보를 가져온 후, 두 번째 \[alt\] 블록(1.1.4.1.2)에서 신청자의 프로필 이미지 존재 여부를 확인합니다. 만약 프로필 이미지가 존재한다면, 서비스는 1.1.4.1.2.1: getFileUrl을 호출하여 S3Uploader를 통해 저장된 파일 키(key)를 실제 접근 가능한 URL로 변환하는 작업을 수행합니다.

이러한 과정을 모든 신청 내역에 대해 반복한 후, ApplicationService는 최종적으로 1.1.4.1.3: \<\<create\>\>를 통해 GetApplicationsResponse 객체를 생성합니다. 이 DTO는 신청자들의 프로필 정보와 변환된 이미지 URL 등이 모두 포함된 목록 형태의 응답 객체입니다.

즉, 이 다이어그램은 '신청 목록 조회'라는 하나의 읽기(Read) 요청이, 실제로는 엄격한 리더 권한 검증을 거친 후에야 여러 리포지토리(ApplicationRepository, UserProfileRepository)와 외부 서비스(S3Uploader)의 데이터를 유기적으로 조합하여 최종 응답을 만들어내는 복잡한 '집계(Aggregation)' 작업임을 구체적으로 보여줍니다.

4.34 그룹 지원서 상세 조회하기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2034.png)
그림 \# sequence 34

이 시퀀스 다이어그램은 사용자가(스터디 리더로 추정) 특정 스터디에 제출된 단일 참여 신청 내역의 상세 정보를 조회할 때, Spring MVC 백엔드 내부에서 동작하는 권한 검증 및 상세 데이터 조회 절차를 단계적으로 나타낸 것입니다.

흐름은 Actor(사용자)가 ApplicationController로 1: getApplicationDetail 요청을 보내면서 시작됩니다. ApplicationController는 이 HTTP 요청을 받아, 조회할 스터디 ID 및 애플리케이션 ID, 그리고 요청자 ID를 ApplicationService의 1.1: getApplicationDetail 메서드로 전달합니다.

ApplicationService는 실제 비즈니스 로직을 처리하는 핵심 주체로서, 데이터 조회를 수행하기 전에 엄격한 권한 검증(Authorization)을 먼저 실시합니다. 서비스는 1.1.1: findByStudyIdAndRole을 호출하여 StudyMemberRepository로부터 해당 스터디의 '리더(Leader)' 정보를 조회합니다. 다이어그램의 \[alt\] 블록(1.1.2)은 이 검증 로직을 명확히 보여줍니다. 만약 조회된 리더의 ID가 현재 요청을 보낸 사용자(requestUserId)의 ID와 일치하지 않는다면, 시스템은 1.1.2.1: \<\<create\>\>를 통해 BusinessException(비즈니스 예외)을 발생시키고 즉시 처리를 중단합니다.

권한이 성공적으로 확인되면, ApplicationService는 1.1.3: findByAppIdAndStudyId를 호출하여 ApplicationRepository에서 조회하려는 특정 'Application' 엔티티를 정확히 찾아옵니다.

엔티티가 성공적으로 조회되면, 서비스는 이 데이터를 바탕으로 1.1.4: \<\<create\>\>를 통해 GetApplicationDetailResponse 객체를 생성합니다. 이 DTO는 신청 내역의 모든 상세 정보가 포함된 응답 객체입니다. 이 객체는 다시 컨트롤러를 거쳐 Actor에게 최종 응답됩니다.

즉, 이 다이어그램은 '신청 상세 조회'라는 읽기(Read) 요청 역시, 엄격한 리더 권한 검증을 통과해야만 실제 데이터에 접근할 수 있음을 구체적으로 보여줍니다.

4.35 그룹 지원 승인하기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2035.png)
그림 \# sequence 35

이 흐름은 ApplicationService의 1.1: handleApplication 메서드가 호출되고, 1.1.5: updateStatus를 통해 신청서의 상태가 '승인(ACCEPTED)'으로 변경된 직후부터 시작됩니다.

이때, 세 번째 \[alt\] 블록(1.1.6)으로 진입하여 '승인'에 특화된 추가 로직이 실행됩니다.

가장 먼저, 스터디의 정원이 꽉 찼는지 확인하는 정원 검사가 수행됩니다(1.1.7). 만약 현재 멤버 수가 최대 멤버 수와 같거나 크다면, 1.1.7.1: \<\<create\>\>를 통해 BusinessException(비즈니스 예외)을 발생시켜 승인 절차를 중단합니다. 이는 정원이 초과되는 것을 방지하기 위한 핵심 비즈니스 규칙입니다.

정원에 여유가 있다면(검증 통과), 서비스는 신청자를 스터디의 정식 멤버로 추가하는 작업을 시작합니다. 1.1.8: builder를 호출하여 StudyMemberBuilder를 가져온 뒤, 승인된 스터디(1.1.9), 사용자 정보(1.1.10), 'MEMBER' 역할(1.1.11), 'ACTIVE' 상태(1.1.12)를 차례로 설정합니다. 그리고 1.1.13: build를 호출하여 새로운 StudyMember 엔티티를 생성합니다. (이 엔티티는 다이어그램에 생략된 Repository.save 호출을 통해 데이터베이스에 저장될 것입니다.)

멤버가 성공적으로 추가된 후, 1.1.14: sendApplicationResultNotification이 호출되어 NotificationService에 '승인' 알림 발송을 요청합니다. NotificationService는 1.1.14.1.1: findById 등으로 신청자의 프로필을 조회하고, NotificationBuilder를(1.1.14.3) 사용해 '스터디에 합류되었음'을 알리는 알림 객체를 최종 생성합니다(1.1.14.9).

요약하면, '승인' 처리는 정원 검사, 신규 멤버 생성, 그리고 승인 알림 발송이라는 세 가지 핵심 하위 작업으로 구성됩니다.

4.36 그룹 지원 거절하기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2036.png)
그림 \# sequence 36

흐름은 ApplicationService의 1.1: handleApplication 메서드가 호출되고, 1.1.1(리더 권한 검증)과 1.1.4(신청서 상태 검증)를 모두 통과한 직후부터 시작됩니다.

서비스는 1.1.5: updateStatus를 호출하여 ApplicationRepository에서 해당 신청서의 상태를 거절(REJECTED)로 변경합니다.

'승인' 처리와 달리, 1.1.6: \[alt\] 블록의 조건이 거짓(false)이 되므로, 해당 블록 전체를 완전히 건너뛰게 됩니다. 즉, 정원 검사(1.1.7)나 StudyMember를 새로 생성(1.1.8)하는 복잡한 로직이 전혀 실행되지 않습니다.

상태가 '거절'로 변경된 후, 흐름은 \[alt\] 블록을 건너뛰고 바로 1.1.14: sendApplicationResultNotification으로 이동하여 NotificationService에 '거절' 알림 발송을 요청합니다.

NotificationService는 1.1.14.1.1: findById 등으로 신청자의 프로필을 조회하고, NotificationBuilder를(1.1.14.3) 사용해 '스터디 참여가 거절되었음'을 알리는 알림 객체를 최종 생성합니다(1.1.14.9).

요약하면, '거절' 처리는 신청서 상태를 'REJECTED'로 변경하고, 신청자에게 '거절' 알림을 발송하는 두 가지 작업으로 완료됩니다.

4.37 내 찜 목록 가져오기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2037.png)
그림 \# sequence 37  
이 시퀀스 다이어그램은 사용자가 찜한 스터디 그룹을 조회할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 StudyQueryController에서 시작된다. 사용자가 내 스터디를 조회하면, 컨트롤러는 이를 StudyQueryService의 getBookmarks로 전달한다.

StudyQueryService는 찜한 스터디를 가져오기 위해 StudyRepository의 findBookmarkedStudyProfiles 메서드를 호출 후 해당 사용자가 속한 스터디들을 조회하여 반환한다.  
반환된 스터디들에 대해 서비스는 정보를 채우기 위해 StudyMemberRepository의 집계함수와 BookmarkRepository의 찜 여부 판단을 위한 exist함수를 사용한다.

수집된 정보를 바탕으로 StudyQueryService는 StudyDto를 생성한 뒤 응답에 필요한 필드를 GetStudiesResponse에담는다. 완성된 응답 객체는 StudyQueryService에서 StudyQueryController로 돌아가고 컨트롤러는 이를 사용자에게 반환한다. 클라이언트는 응답된 정보를 화면에 랜더링한다.

4.38 내 그룹 데이터 가져오기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2038.png)
그림 \# sequence 38  
이 시퀀스 다이어그램은 사용자가 속한 스터디 그룹을 조회할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.

요청은 StudyQueryController에서 시작된다. 사용자가 내 스터디를 조회하면, 컨트롤러는 이를 StudyQueryService의 getMyStudies로 전달한다.  
StudyQueryService는 먼저 사용자가 소속된 스터디를 가져오기 위해 StudyRepository의 조회 메서드를 호출 후 해당 사용자가 속한 스터디들을 조회하여 반환한다.  
반환된 스터디들에 대해 서비스는 정보를 채우기 위해 StudyMemberRepository의 집계함수와 BookmarkRepository의 찜 여부 판단을 위한 exist함수를 사용한다.

수집된 정보를 바탕으로 StudyQueryService는 StudyDto를 생성한 뒤 응답에 필요한 필드를 GetStudiesResponse에담는다. 완성된 응답 객체는 StudyQueryService에서 StudyQueryController로 돌아가고 컨트롤러는 이를 사용자에게 반환한다. 클라이언트는 응답된 정보를 화면에 랜더링한다.

4.39 과제 목록 가져오기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2039.png)
그림 \# sequence 39  
이 시퀀스 다이어그램은 사용자가 과제의 목록을 조회할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 AssignmentController에서 시작되며 클라이언트가 studyId와 userId를 포함해 AssignmentService의 getAssignments로 전달한다.

Assignment는 먼저 studyId나 userId가 null면 BusinessException을 발생시킨다. 검증을 통과하면 GroupService의 membervalidation을 호출해 사용자가 해당 스터디의 그룹원인지 검증 후 멤버가 아니라면 BusinessException을 발생시킨다.  
멤버 검증을 통과하면 과제 목록을 가져오기 위해 AssignmentRepository의 조회 명령어를 호출해 과제의 목록을 시간순대로 내림차순해 조회한다. 반환된 리스트를 바탕으로 GetAssignmentResponse를 build한 뒤 AssignmentController로 반환한다.

컨트롤러는 서비스에서 받은 응답을 사용자에게 전달하며, 사용자는 과제 목록을 화면에 렌더링한다.

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2040.png)
그림 \# sequence 40  
이 시퀀스 다이어그램은 사용자가 과제를 생성할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 AssignmentController에서 시작된다. 사용자가 studyId와 과제 생성 요청 DTO를 전송하면 컨트롤러는 이를 AssignmentService의 createAssignment로 전달한다.

AssignmentService는 studyId나 userId가 null이면 BusinessException을 발생시키고 검증을 통과하면 GroupService의 membervalidation을 호출해 사용자가 해당 스터디의 그룹원인지 검증 후 멤버가 아니라면 BusinessException을 발생시킨다. 그 후 사용자가 해당 스터디그룹의 리더가 아니라면 BusinessException을 발생시킨다.  
검증 과정을 모두 통과하면 요청받은 DTO를 기반으로 Assignment 엔티리르 생성해 AssignmentRepository의 save함수를 통해 이를 저장한다. 저장 결과로 해당 과제의 id가 부여된다. 첨부파일이 존재한다면 S3Uploader로 원본파일을 업로드해 파일의 정보를 통해 File 엔티티를 생성하고 FileRepository의 save함수를 사용해 이를 저장한다. 파일 업로드 실패시 예외를 던지고 트랜잭션 롤백을 진행한다.  
그 후 과제 생성 알림을 만들기 위해 NotificationService의 addAssignmentNotice를 호출한 뒤 Notification Repository의 save로 이를 저장한다. 그 후 생성된 과제의 id를 AssignmentController에게 전달한다.

컨트롤러는 전달받은 id를 통해 url를 만들어 이를 사용자에게 반환하게 된다.

4.41 과제 수정하기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2041.png)   
그림 \# sequence 41  
이 시퀀스 다이어그램은 사용자가 과제를 수정할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 AssignmentController에서 시작된다. 사용자가 studyId와 과제 수정 요청 DTO를 전송하면 컨트롤러는 이를 AssignmentService의 updateAssignment로 전달한다.

AssignmentService는 studyId, userId, assignmentId가 null이면 BusinessException을 발생시키고 검증을 통과하면 GroupService의 membervalidation을 호출해 사용자가 해당 스터디의 그룹원인지 검증 후 멤버가 아니라면 BusinessException을 발생시킨다. 그 후 사용자가 해당 스터디그룹의 리더가 아니라면 BusinessException을 발생시킨다.  
검증작업을 통과하면 기존의 과제 엔티티의 값을 입력받은 DTO의 값으로 변경한다. 그 후 파일의 삭제 목록이 있다면 파일의 연관관계를 해제한 뒤 s3 객체 삭제 후 파일 엔티티를 정리하게 된다. 또한 신규 파일이 있다면 과제의 생성 부분과 동일하게 S3Uploader로 원본파일을 업로드해 파일의 정보를 통해 File 엔티티를 생성하고 FileRepository의 save함수를 사용해 이를 저장한다. 파일 업로드 실패시 예외를 던지고 트랜잭션 롤백을 진행한다.

컨트롤러는 클라이언트에게 ok(200)코드를 반환한다.

4.42 과제 삭제하기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2042.png) 
그림 \# sequence 42  
이 시퀀스 다이어그램은 사용자가 과제를 삭제할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 AssignmentController에서 시작된다. 사용자가 studyId를 전송하면 컨트롤러는 이를 AssignmentService의 deleteAssignment로 전달한다.

AssignmentService는 studyId, userId, assignmentId가 null이면 BusinessException을 발생시키고 검증을 통과하면 GroupService의 membervalidation을 호출해 사용자가 해당 스터디의 그룹원인지 검증 후 멤버가 아니라면 BusinessException을 발생시킨다. 그 후 사용자가 해당 스터디그룹의 리더가 아니라면 BusinessException을 발생시킨다.  
검증작업을 통과하면 대상 과제를 AssignmentRepository에서 조회한 뒤 과제를 삭제하기 전 과제의 과제 제출물을 모두 제거한 후 과제 파일의 연관관계를 해제 후 모두 제거한다. 그후 AssignmentRepository의 deleteById를 통해 과제를 삭제하게 된다.  
컨트롤러는 클라이언트에게 200(ok)코드를 반환한다.

4.43 과제 상세 내용 가져오기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2043.png)
그림 \# sequence 43  
이 시퀀스 다이어그램은 사용자가 과제의 상세내용을 가져올 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 AssignmentController에서 시작된다. 사용자가 studyId, assignmentId와 userId를 전송하면 컨트롤러는 이를 AssignmentService의 getAssignmentDetail로 전달한다.

AssignmentService는 studyId, userId, assignmentId가 null이면 BusinessException을 발생시키고 검증을 통과하면 GroupService의 membervalidation을 호출해 사용자가 해당 스터디의 그룹원인지 검증 후 멤버가 아니라면 BusinessException을 발생시킨다.  
검증을 통과하면 해당 과제의 상세 내용을 AssignmentRepository의 조회메서드로 가져온 뒤 과제 제출물 목록을 SubmissionRepository의 findSubmissionList메서드를 통해 제출물을 가져온 뒤 과제에 첨부된 파일 목록을 가져온다. 과제 정보와 과제 파일과 제출물 목록을 GetAssignmentDetailResponse로 build후 AssignmentController에게 전달한다.

컨트롤러는 전달받은 GetAssignmentDetailResponse를 사용자에게 반환한다.

4.44 과제 제출하기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2044.png) 
그림 \# sequence 44  
이 시퀀스 다이어그램은 사용자가 과제의 제출물을 제출할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 SubmissionController에서 시작된다. 사용자가 studyId, assignmentId, userId, 요청DTO 를 전송하면 컨트롤러는 이를 SubmissionService의 submitSubmission로 전달한다.

SubmissionService는 studyId, userId, assignmentId가 null이면 BusinessException을 발생시키고 검증을 통과하면 GroupService의 membervalidation을 호출해 사용자가 해당 스터디의 그룹원인지 검증 후 멤버가 아니라면 BusinessException을 발생시킨다. 그 후 SubmissionRepository의 조회를 통해 이미 과제 제출물을 제출했는지 확인하고 이미 제출했다면 BusinessException을 발생시킨다.  
검증작업을 통과하면 요청받은 DTO를 바탕으로 Submission 엔티티를 생성한 뒤 SubmissionRepository의 save메서드를 통해 이를 저장한다. 또한 첨부파일이 존재한다면 S3Uploader로 원본파일을 업로드해 파일의 정보를 통해 File 엔티티를 생성하고 FileRepository의 save함수를 사용해 이를 저장한다. 파일 업로드 실패시 예외를 던지고 트랜잭션 롤백을 진행한다.  
서비스는 저장된 Submission의 id를 SubmissionController에 반환한다.

컨트롤러는 Submission의 id를 통해 url을 만들고 클라이언트에게 201(created)코드와 만들어진 url을 반환한다.  
 

4.45 과제 제출물 상세 데이터 가져오기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2045.png)  
그림 \# sequence 45  
이 시퀀스 다이어그램은 사용자가 과제의 제출물의 상세보기할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 SubmissionController에서 시작된다. 사용자가 studyId, assignmentId, userId, submissionId를 전송하면 컨트롤러는 이를 SubmissionService의 getSubmissionDetail로 전달한다.

SubmissionService는 studyId, userId, assignmentId, submissionId가 null이면 BusinessException을 발생시키고 검증을 통과하면 GroupService의 membervalidation을 호출해 사용자가 해당 스터디의 그룹원인지 검증 후 멤버가 아니라면 BusinessException을 발생시킨다.  
검증을 통과하면 UserService를 통해 제출자의 닉네임과 프로필 이미지를 조회하고 제출물에 연결된 첨부파일 목록을 조회하여 해당 정보들을 GetSubmissionDetailResponse의 build를 사용해 응답 DTO를 만들어 SubmissionController에게 전달한다.

컨트롤러는 전달받은 DTO를 사용자에게 반환한다.  
4.46 과제 평가하기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2046.png)
그림 \# sequence 46  
이 시퀀스 다이어그램은 사용자가 과제의 제출물을 피드백할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 FeedbackController에서 시작된다. 사용자가 studyId, assignmentId, userId, submissionId와 요청 DTO를 전송하면 컨트롤러는 이를 FeedbackService의 addFeedback으로 전달한다.

SubmissionService는 studyId, userId, assignmentId, submissionId가 null이면 BusinessException을 발생시키고 검증을 통과하면 GroupService의 membervalidation을 호출해 사용자가 해당 스터디의 그룹원인지 검증 후 멤버가 아니라면 BusinessException을 발생시킨다. 기본적으로 해당 시스템은 자신의 제출물을 피드백할 수 없기 때문에 피드백을 하는 사용자의 아이디가 과제 제출자의 id와 같다면 BusinessException을 발생시키고 FeedbackRepository의 exist 메서드를 통해 이미 피드백을 제출했다면 BusinessException을 발생시킨다.  
검증작업을 통과하면 요청DTO를 바탕으로 해당 제출물의 Feedback 엔티티를 생성해 FeedbackRepository의 save를 통해 해당 엔티티를 저장한다. 이 때 updateTrustScore 메서드를 통해 피드백의 점수가 제출자의 신뢰점수에 반영된다. 그 후 FeedbackService에 생성된 Feedback의 id를 반환한다.

컨트롤러는 반환된 id를 통해 url을 만들어 201(created)코드와 함께 url을 클라이언트에 반환한다.

4.47 과제 평가 목록 가져오기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2047.png)
그림 \# sequence 47  
이 시퀀스 다이어그램은 사용자가 과제 제출물의 피드백 목록을 조회할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 FeedbackController에서 시작된다. 사용자가 studyId, assignmentId, userId, submissionId를 전송하면 컨트롤러는 이를 FeedbackService의 getFeedbacks으로 전달한다.

SubmissionService는 studyId, userId, assignmentId, submissionId가 null이면 BusinessException을 발생시키고 검증을 통과하면 GroupService의 membervalidation을 호출해 사용자가 해당 스터디의 그룹원인지 검증 후 멤버가 아니라면 BusinessException을 발생시킨다.   
검증작업을 통과하면 FeedbackRepository의 findAllBySubmissionId메서드를 통해 제출물의 피드백 목록을 조회하여 GetFeedbackListResponse를 생성해 FeedbackController에 반환한다.

컨트롤러는 반환된 값을 사용자에게 반환하며 사용자는 제출물 상세 화면을 렌더링한다.  
4.48 알림 목록 가져오기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/4c4ea59049fc217eb6b45a1f0e0a8556aeef0905/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2048.png)
그림 \# sequence 48  
이 시퀀스 다이어그램은 사용자가 그룹의 알림 목록을 조회할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 NotificationController에서 시작된다. 사용자가 studyId, userId를 전송하면 컨트롤러는 이를 NotificationService의 getNotifications으로 전달한다.

NotificationService는 studyId, userId가 null이면 BusinessException을 발생시키고 검증을 통과하면 GroupService의 membervalidation을 호출해 사용자가 해당 스터디의 그룹원인지 검증 후 멤버가 아니라면 BusinessException을 발생시킨다.   
검증을 통과하면 NotificationRepository의 findAllByStudy를 통해 해당 그룹의 알림 목록을 조회한 뒤 조회된 리스트의 알림 id와 제목을 포함해 GetNotificationsListResponse를 만들어 NotificationController에 전달한다.

컨트롤러는 해당 목록을 사용자에게 반환하고 사용자의 알림 목록 화면을 렌더링한다.

4.49. 채팅목록 가져오기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/23a3a62cfdc7ee4749c7a9f6ba7ab05da6b58080/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%2049.png)

그림 \#  sequence 49

이 시퀀스 다이어그램은 사용자가 채팅방에 접속했을 때, Spring MVC 백엔드 내부에서 메시지 데이터를 조회하고 사용자 프로필 정보를 함께 구성하여 채팅 목록을 반환하는 과정을 단계적으로 나타낸 것이다.  
 요청은 ChatRestController에서 시작된다. 사용자가 채팅방에 진입하거나 스크롤을 통해 이전 메시지를 요청하면, 컨트롤러는 ChatService의 getMessages 메서드를 호출한다.

ChatService는 우선 요청 파라미터로 전달된 마지막 메시지 ID의 존재 여부를 판단한다. 만약 메시지 ID가 존재하지 않는 경우, 최근 메시지를 불러오기 위해 ChatMessageRepository의 findRecentMessages 메서드를 호출한다. 반대로 특정 시점 이전의 메시지를 불러와야 하는 경우에는 findMessagesBefore 메서드가 실행되어 해당 시점 이전의 채팅 데이터를 조회한다.

조회된 각 메시지에 대해 서비스는 발신자의 프로필 정보를 가져오기 위해 UserProfileRepository의 findByUser 메서드를 호출한다. 사용자 프로필이 존재하지 않을 경우 BusinessException을 발생시켜 예외를 처리하거나, 기본 프로필 데이터를 생성한다.  
 프로필 이미지가 등록되어 있는 경우에는 S3Uploader의 getUrlFile 메서드를 통해 이미지 파일의 접근 경로(URL)를 불러오고, 내부적으로 validateKey 메서드를 호출하여 이미지 키의 유효성을 검증한다.

이후 ChatMessageResponseBuilder가 실행되어 각 메시지의 세부 정보를 구성한다. 이 단계에서는 메시지 ID, 발신자 ID, 닉네임, 프로필 이미지 URL, 메시지 내용, 전송 시각 등의 정보가 순차적으로 설정된다. 모든 필드가 완성되면 ChatMessageResponse 객체가 생성되어 ChatService로 반환된다.

ChatService는 전체 메시지 목록을 정리하여 ChatRestController로 전달하고, 컨트롤러는 이를 클라이언트에 반환한다. 클라이언트는 응답 데이터를 이용해 채팅 화면에 메시지를 시간 순서대로 출력한다.

4.50. 채팅하기

![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/23a3a62cfdc7ee4749c7a9f6ba7ab05da6b58080/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20%20sequence%2050.png)

그림 \#  sequence 50

이 시퀀스 다이어그램은 사용자가 채팅방 내에서 메시지를 전송할 때, Spring MVC 백엔드 내부에서 수행되는 처리 과정을 단계적으로 나타낸 것이다.  
 요청은 ChatWebSocketController에서 시작된다. 사용자가 메시지를 전송하면, 컨트롤러는 WebSocket을 통해 수신된 데이터를 ChatService의 handleMessage 메서드로 전달한다. 이때 TokenProvider를 통해 전달받은 토큰이 검증되어 발신자의 사용자 정보가 추출된다.

ChatService는 먼저 사용자가 실제로 해당 스터디 채팅방의 구성원인지 확인하기 위해 StudyMemberRepository를 호출한다. findByStudyAndUserAndStatus 메서드를 통해 사용자가 스터디에 참여 중인 멤버인지 확인하고, 존재하지 않을 경우 BusinessException을 발생시켜 예외를 처리한다. 이후 사용자와 스터디 정보가 정상적으로 확인되면, ChatMessage 엔티티를 생성하기 위한 빌드 과정이 진행된다.

ChatMessageBuilder는 메시지의 주요 속성들을 순차적으로 설정한다. 이 과정에서 study, user, sender, content 등의 필드가 채워지며, 최종적으로 build 메서드를 통해 완성된 ChatMessage 객체가 생성된다. 이후 ChatMessageRepository를 통해 해당 메시지가 데이터베이스에 저장된다.

메시지 전송자가 프로필 이미지를 보유한 경우에는 UserProfileRepository를 호출하여 프로필 데이터를 조회하고, S3Uploader의 getUrlFile 메서드를 통해 이미지 URL을 불러온다. 이미지 키가 유효한지 검증하기 위해 validateKey 메서드가 함께 수행된다.

이후 ChatMessageResponseBuilder가 실행되어 메시지 응답 객체를 구성한다. 빌더는 메시지 ID, 발신자 ID, 닉네임, 프로필 이미지 URL, 메시지 내용, 생성 시각 등의 필드를 순차적으로 채운 뒤, ChatMessageResponse 객체를 생성한다. 생성된 응답은 다시 ChatWebSocketController로 반환되어 WebSocket 세션을 통해 모든 참여자에게 브로드캐스팅된다.

4.51 알림 상세 데이터 가져오기  
![](https://github.com/StudyGroup-Project/StudyGroup_Project/blob/23a3a62cfdc7ee4749c7a9f6ba7ab05da6b58080/documents/image/sequence%20image/%EA%B7%B8%EB%A6%BC%20%23%20sequence%2051.png)
그림 \# sequence 51  
이 시퀀스 다이어그램은 사용자가 그룹의 알림의 상세정보를 조회할 때, Spring MVC 백엔드 내부에서 수행되는 검색 처리 과정을 단계적으로 나타낸 것이다.  
요청은 NotificationController에서 시작된다. 사용자가 studyId, notificationId, userId를 전송하면 컨트롤러는 이를 NotificationService의 getNotificationDetail으로 전달한다.

NotificationService는 studyId, notificationId, userId가 null이면 BusinessException을 발생시키고 검증을 통과하면 GroupService의 membervalidation을 호출해 사용자가 해당 스터디의 그룹원인지 검증 후 멤버가 아니라면 BusinessException을 발생시킨다.   
검증을 통과하면 NotificationRepository의 findById를 통해 해당 알림을 조회한 뒤 조회된 알림의 제목, 내용, 생성일을 GetNotificationDetailResponseBuilder를 통해 GetNotificationDetailResponse를 만들어 NotificationController에 전달한다.

컨트롤러는 해당 DTO를 사용자에게 반환하고 사용자의 알림 상세 화면을 렌더링한다  



